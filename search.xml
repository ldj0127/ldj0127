<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Data、String和sql.Timestamp之间的互相转换</title>
    <url>/2020/01/22/java-zhong-data-string-he-sql.timestamp-zhi-jian-de-hu-xiang-zhuan-huan/</url>
    <content><![CDATA[<h1 id="JAVA中java-util-Date、java-sql-Timestamp和String之间的互相转换"><a href="#JAVA中java-util-Date、java-sql-Timestamp和String之间的互相转换" class="headerlink" title="JAVA中java.util.Date、java.sql.Timestamp和String之间的互相转换"></a>JAVA中java.util.Date、java.sql.Timestamp和String之间的互相转换</h1><h2 id="java-util-Date与的String互转"><a href="#java-util-Date与的String互转" class="headerlink" title="java.util.Date与的String互转"></a>java.util.Date与的String互转</h2><h3 id="java-util-Date—-gt-String"><a href="#java-util-Date—-gt-String" class="headerlink" title="java.util.Date—-&gt;String"></a>java.util.Date—-&gt;String</h3><pre><code>/**
 * 将java.util.Date对象转化为String字符串
 * @param date
 *            要格式的java.util.Date对象
 * @param strFormat
 *            输出的String字符串格式的限定（如：&quot;yyyy-MM-dd HH:mm:ss&quot;）
 * @return 表示日期的字符串
 */
public static String dateToStr(java.util.Date date, String strFormat) {
    SimpleDateFormat sf = new SimpleDateFormat(strFormat);
    String str = sf.format(date);
    return str;
}</code></pre><h3 id="String—-gt-java-util-Date"><a href="#String—-gt-java-util-Date" class="headerlink" title="String—-&gt;java.util.Date"></a>String—-&gt;java.util.Date</h3><pre><code>/**
 * 将String字符串转换为java.util.Date格式日期
 * @param strDate
 *            表示日期的字符串
 * @param dateFormat
 *            传入字符串的日期表示格式（如：&quot;yyyy-MM-dd HH:mm:ss&quot;）
 * @return java.util.Date类型日期对象（如果转换失败则返回null）
 */
public static java.util.Date strToUtilDate(String strDate, String dateFormat) {
    SimpleDateFormat sf = new SimpleDateFormat(dateFormat);
    java.util.Date date = null;
    try {
        date = sf.parse(strDate);
    } catch (ParseException e) {
        e.printStackTrace();
    }
    return date;
}</code></pre><h2 id="java-sql-Timestamp与的String互转"><a href="#java-sql-Timestamp与的String互转" class="headerlink" title="java.sql.Timestamp与的String互转"></a>java.sql.Timestamp与的String互转</h2><h3 id="java-sql-Timestamp—-gt-String"><a href="#java-sql-Timestamp—-gt-String" class="headerlink" title="java.sql.Timestamp—-&gt;String"></a>java.sql.Timestamp—-&gt;String</h3><pre><code>/**
 * 将java.sql.Timestamp对象转化为String字符串
 * @param time
 *            要格式的java.sql.Timestamp对象
 * @param strFormat
 *            输出的String字符串格式的限定（如：&quot;yyyy-MM-dd HH:mm:ss&quot;）
 * @return 表示日期的字符串
 */
public static String dateToStr(java.sql.Timestamp time, String strFormat) {
    DateFormat df = new SimpleDateFormat(strFormat);
    String str = df.format(time);
    return str;
}</code></pre><h3 id="String—-gt-java-sql-Timestamp"><a href="#String—-gt-java-sql-Timestamp" class="headerlink" title="String—-&gt;java.sql.Timestamp"></a>String—-&gt;java.sql.Timestamp</h3><pre><code>/**
 * 将String字符串转换为java.sql.Timestamp格式日期,用于数据库保存
 * @param strDate
 *            表示日期的字符串
 * @param dateFormat
 *            传入字符串的日期表示格式（如：&quot;yyyy-MM-dd HH:mm:ss&quot;）
 * @return java.sql.Timestamp类型日期对象（如果转换失败则返回null）
 */
public static java.sql.Timestamp strToSqlDate(String strDate, String dateFormat) {
    SimpleDateFormat sf = new SimpleDateFormat(dateFormat);
    java.util.Date date = null;
    try {
            date = sf.parse(strDate);
    } catch (ParseException e) {
            e.printStackTrace();
    }
    java.sql.Timestamp dateSQL = new java.sql.Timestamp(date.getTime());
    return dateSQL;
}</code></pre><h2 id="java-util-Date与的java-sql-Timestamp互转"><a href="#java-util-Date与的java-sql-Timestamp互转" class="headerlink" title="java.util.Date与的java.sql.Timestamp互转"></a>java.util.Date与的java.sql.Timestamp互转</h2><h3 id="java-util-Date—-gt-java-sql-Timestamp（用String做中间变量，此方法依赖于上面的方法）"><a href="#java-util-Date—-gt-java-sql-Timestamp（用String做中间变量，此方法依赖于上面的方法）" class="headerlink" title="java.util.Date—-&gt;java.sql.Timestamp（用String做中间变量，此方法依赖于上面的方法）"></a>java.util.Date—-&gt;java.sql.Timestamp（用String做中间变量，此方法依赖于上面的方法）</h3><pre><code>/**
 * 将java.util.Date对象转化为java.sql.Timestamp对象
 *
 * @param date
 *            要转化的java.util.Date对象
 * @return 转化后的java.sql.Timestamp对象
 */
public static java.sql.Timestamp dateToTime(java.util.Date date) {
    String strDate = dateToStr(date, &quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
    return strToSqlDate(strDate, &quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
}</code></pre><h3 id="java-sql-Timestamp—-gt-java-util-Date（二者是父子关系，可以直接赋值，自动转换）"><a href="#java-sql-Timestamp—-gt-java-util-Date（二者是父子关系，可以直接赋值，自动转换）" class="headerlink" title="java.sql.Timestamp—-&gt;java.util.Date（二者是父子关系，可以直接赋值，自动转换）"></a>java.sql.Timestamp—-&gt;java.util.Date（二者是父子关系，可以直接赋值，自动转换）</h3><pre><code>/**
 * 将java.sql.Timestamp对象转化为java.util.Date对象
 * 
 * @param time
 *            要转化的java.sql.Timestamp对象
 * @return 转化后的java.util.Date对象
 */
public static java.util.Date timeToDate(java.sql.Timestamp time) {
    return time;
}</code></pre><h2 id="完整的类在这"><a href="#完整的类在这" class="headerlink" title="完整的类在这"></a>完整的类在这</h2><pre><code>import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;

/**
 * 关于java.util.Date、java.sql.Timestamp和String之间的互相转换的方法
 * @Description: TODO
 * @CreateTime: 2017年10月25日 下午3:20:44
 * @version V1.0
 */
public class DateUtil {

    /**
     * 将String字符串转换为java.util.Date格式日期
     * 
     * @param strDate
     *            表示日期的字符串
     * @param dateFormat
     *            传入字符串的日期表示格式（如：&quot;yyyy-MM-dd HH:mm:ss&quot;）
     * @return java.util.Date类型日期对象（如果转换失败则返回null）
     */
    public static java.util.Date strToUtilDate(String strDate, String dateFormat) {
        SimpleDateFormat sf = new SimpleDateFormat(dateFormat);
        java.util.Date date = null;
        try {
            date = sf.parse(strDate);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return date;
    }

    /**
     * 将String字符串转换为java.sql.Timestamp格式日期,用于数据库保存
     * 
     * @param strDate
     *            表示日期的字符串
     * @param dateFormat
     *            传入字符串的日期表示格式（如：&quot;yyyy-MM-dd HH:mm:ss&quot;）
     * @return java.sql.Timestamp类型日期对象（如果转换失败则返回null）
     */
    public static java.sql.Timestamp strToSqlDate(String strDate, String dateFormat) {
        SimpleDateFormat sf = new SimpleDateFormat(dateFormat);
        java.util.Date date = null;
        try {
            date = sf.parse(strDate);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        java.sql.Timestamp dateSQL = new java.sql.Timestamp(date.getTime());
        return dateSQL;
    }

    /**
     * 将java.util.Date对象转化为String字符串
     * 
     * @param date
     *            要格式的java.util.Date对象
     * @param strFormat
     *            输出的String字符串格式的限定（如：&quot;yyyy-MM-dd HH:mm:ss&quot;）
     * @return 表示日期的字符串
     */
    public static String dateToStr(java.util.Date date, String strFormat) {
        SimpleDateFormat sf = new SimpleDateFormat(strFormat);
        String str = sf.format(date);
        return str;
    }

    /**
     * 将java.sql.Timestamp对象转化为String字符串
     * 
     * @param time
     *            要格式的java.sql.Timestamp对象
     * @param strFormat
     *            输出的String字符串格式的限定（如：&quot;yyyy-MM-dd HH:mm:ss&quot;）
     * @return 表示日期的字符串
     */
    public static String dateToStr(java.sql.Timestamp time, String strFormat) {
        DateFormat df = new SimpleDateFormat(strFormat);
        String str = df.format(time);
        return str;
    }

    /**
     * 将java.sql.Timestamp对象转化为java.util.Date对象
     * 
     * @param time
     *            要转化的java.sql.Timestamp对象
     * @return 转化后的java.util.Date对象
     */
    public static java.util.Date timeToDate(java.sql.Timestamp time) {
        return time;
    }

    /**
     * 将java.util.Date对象转化为java.sql.Timestamp对象
     * 
     * @param date
     *            要转化的java.util.Date对象
     * @return 转化后的java.sql.Timestamp对象
     */
    public static java.sql.Timestamp dateToTime(java.util.Date date) {
        String strDate = dateToStr(date, &quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
        return strToSqlDate(strDate, &quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
    }

    /**
     * 返回表示系统当前时间的java.util.Date对象
     * @return  返回表示系统当前时间的java.util.Date对象
     */
    public static java.util.Date nowDate(){
        return new java.util.Date();
    }

    /**
     * 返回表示系统当前时间的java.sql.Timestamp对象
     * @return  返回表示系统当前时间的java.sql.Timestamp对象
     */
    public static java.sql.Timestamp nowTime(){
        return dateToTime(new java.util.Date());
    }
}</code></pre>]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>Date、String和sql.Timestamp转换</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记</title>
    <url>/2020/01/18/maven-xue-xi-bi-ji/</url>
    <content><![CDATA[<h2 id="1、目前掌握的技术"><a href="#1、目前掌握的技术" class="headerlink" title="1、目前掌握的技术"></a>1、目前掌握的技术</h2><p><img src="https://img-blog.csdn.net/20170727170011085?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="2、目前的技术在开发中存在的问题-why"><a href="#2、目前的技术在开发中存在的问题-why" class="headerlink" title="2、目前的技术在开发中存在的问题[why]"></a>2、目前的技术在开发中存在的问题[why]</h2><ol>
<li>一个项目就是一个工程如果项目非常庞大，就不适合继续使用package来划分模块。最好是每一个模块对应一个项目，利于分工协作。借助于maven就可以将一个项目拆分成多个工程。</li>
<li>项目中需要的jar包必须手动“复制”、”粘贴” 到WEB-INF/lib 项目下带来的问题：同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外也让工程比较臃肿。借助Maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程“引用”这个文件，并不需要重复复制。</li>
<li>jar包需要别人替我们准备好，或到官网下载所有知名框架或第三方工具jar包已经按照统一规范放在了Maven的中央仓库中。</li>
<li>个jar包依赖的其他jar包需要自己手动加到项目中<br>Maven会自动将被依赖的jar包导入进来。</li>
</ol>
<h2 id="3、Maven是什么-what"><a href="#3、Maven是什么-what" class="headerlink" title="3、Maven是什么[what]"></a>3、Maven是什么[what]</h2><ol>
<li>Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理 。Maven 这个单词的本意是：专家，内行。读音是[‘meɪv(ə)n]或[‘mevn]。构建工具的发展：Make→Ant→Maven→Gradle</li>
<li>构建：就是以我们编写的Java代码、框架配置文件、国际化等其他资源文件、jsp页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。<br>eclipse中的项目与tomcat中编译结果对比：<br><img src="https://img-blog.csdn.net/20170728201331986?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>构建过程中的几个主要环节<br>①清理：删除以前的编译结果，为重新编译做好准备。<br>②编译：将Java源程序编译为字节码文件。<br>③测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。<br>④报告：将每一次测试后以标准的格式记录和展示测试结果。<br>⑤打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应jar包，Web工程对象war包。<br>⑥安装：在Maven环境下特指将打包的结果——Jar包或War包安装到本地仓库中。<br>⑦部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行。</li>
<li>自动化构建<br>程序员一天的工作：<br><img src="https://img-blog.csdn.net/20170728203846138?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>能否将这些程式化的工作交给机器自动完成呢？——当然可以！这就是自动化构建。<br><img src="https://img-blog.csdn.net/20170728203927253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>此时 Maven 的意义就体现出来了，它可以自动的从构建过程的起点一直执行到终点：<br><img src="https://img-blog.csdn.net/20170728203953999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
</ol>
<h2 id="4、安装Maven核心程序"><a href="#4、安装Maven核心程序" class="headerlink" title="4、安装Maven核心程序"></a>4、安装Maven核心程序</h2><ol>
<li>检查JAVA_HOME环境变量<blockquote>
<p>cmd输入echo %JAVA_HOME%<br>C:\Program Files\Java\jdk1.8.0_181</p>
</blockquote>
</li>
<li>解压Maven核心程序的压缩包，放在一个<strong>非中文、无空格</strong>的路径下<blockquote>
<p>D:\apache-maven-3.6.3</p>
</blockquote>
</li>
<li>配置Maven相关的环境变量<br>①MAVEN_HOME 或 M2_HOME<br><img src="https://img-blog.csdn.net/20170728211509244?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>②path<br><img src="https://img-blog.csdn.net/20170728211603564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>验证：运行 mvn -v 命令查看Maven版本<blockquote>
<p>C:\Users\Lenovo&gt;mvn -v<br>Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)<br>Maven home: D:\apache-maven-3.6.3\bin..<br>Java version: 1.8.0_181, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk1.8.0_181\jre<br>Default locale: zh_CN, platform encoding: GBK<br>OS name: “windows 10”, version: “10.0”, arch: “amd64”, family: “windows”</p>
</blockquote>
</li>
</ol>
<h2 id="5、Maven的核心概念"><a href="#5、Maven的核心概念" class="headerlink" title="5、Maven的核心概念"></a>5、Maven的核心概念</h2><ol>
<li>约定的目录结构</li>
<li>POM</li>
<li>坐标</li>
<li>依赖</li>
<li>仓库</li>
<li>生命周期/插件/目标</li>
<li>继承</li>
<li>聚合</li>
</ol>
<h2 id="6、第一个Maven工程"><a href="#6、第一个Maven工程" class="headerlink" title="6、第一个Maven工程"></a>6、第一个Maven工程</h2><ol>
<li>创建约定的目录结构<br><img src="https://img-blog.csdn.net/20170728213202634?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>pom.xml文件为Maven工程的核心配置文件</li>
<li>为什么要遵循约定的目录结构呢？<br>我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式：<br>①以配置文件的方式明确告诉框架 如 &lt; param-value&gt;classpath:spring-context.xml &lt; /param-value&gt;<br>②遵循框架内部已经存在的约定 如log4j的配置文件名规定必须为 log4j.properties 或 log4j.xml ；Maven 使用约定的目录结构</li>
</ol>
<h2 id="7、Maven常用命令"><a href="#7、Maven常用命令" class="headerlink" title="7、Maven常用命令"></a>7、Maven常用命令</h2><ol>
<li>注意：执行与构建过程相关的Maven命令，必须进入pom.xml 所在的目录。</li>
<li>常用命令<br>【1】mvn clean : 清理<br>【2】mvn compile : 编译主程序<br>【3】mvn test-compile : 编译测试程序<br>【4】mvn test : 执行测试<br>【5】mvn package : 打包<br>【6】mvn install ： 安装<br>【7】mvn site ：生成站点</li>
</ol>
<h2 id="8、关于联网问题"><a href="#8、关于联网问题" class="headerlink" title="8、关于联网问题"></a>8、关于联网问题</h2><ol>
<li>Maven 的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须有特定的插件来完成。而插件本身不包含在Maven核心程序中。</li>
<li>当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。</li>
<li>本地仓库的默认位置：[系统登陆用户的家目录] \ .m2\repository</li>
<li>Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。</li>
<li>如果此时无法连接外网，则构建失败。</li>
<li>修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件<br>①找到Maven解压目录\conf\settings.xml<br>②在setting.xml 文件中找到 localRepository 标签<br>③将 &lt; localRepository&gt;/path/to/local/repo&lt; /localRepository&gt;从注释中取<br>出<br>④将标签体内容修改为自定义的Maven仓库目录</li>
</ol>
<h2 id="9、POM"><a href="#9、POM" class="headerlink" title="9、POM"></a>9、POM</h2><ol>
<li>含义：Project Object Model 项目对象模型<br>DOM ：Document Object Model 文档对象模型</li>
<li>pom.xml 对于 Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置。<br>重要程度相当于web.xml 对于动态web工程</li>
</ol>
<h2 id="10、坐标"><a href="#10、坐标" class="headerlink" title="10、坐标"></a>10、坐标</h2><ol>
<li><p>数学中的坐标：<br>①在平面中，使用X,Y坐标可以唯一的定位平面中任何一个点。<br>②在空间中，使用X,Y，Z三个向量可以唯一的定位空间中的任何一个点。</p>
</li>
<li><p>Maven的坐标：<br>使用下面三个向量在仓库中唯一定位一个Maven工程<br>①groupid:公司或组织域名倒序+项目名</p>
<pre><code> &lt; groupid&gt;com.atguigu.maven&lt; /groupid&gt;</code></pre><p>②artifactid:模块名</p>
<pre><code> &lt; artifactid&gt;Hello&lt; /artifactid&gt;  </code></pre><p>③version：版本  </p>
<pre><code> &lt; version&gt;1.0.0&lt; /version&gt;</code></pre></li>
<li><p>Maven 工程的坐标与仓库中路径的对应关系，以spring为例</p>
<pre><code> &lt; groupId&gt;org.springframework&lt; /groupId&gt;
 &lt; artifactId&gt;spring-core&lt; /artifactId&gt;
 &lt; version&gt;4.0.0.RELEASE&lt; /version&gt;
 org/springframework/spring-core/4.0.0.RELEASE/spring-core-4.0.0.RELEASE.jar</code></pre></li>
</ol>
<p>注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install</p>
<h2 id="11、仓库"><a href="#11、仓库" class="headerlink" title="11、仓库"></a>11、仓库</h2><ol>
<li>仓库的分类<br>①本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有Maven工程服务<br>②远程仓库<br>（1）私服：搭建在局域网环境中，为局域网范围内的所有Maven工程服务<br><img src="https://img-blog.csdn.net/20170729222712252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>（2）中央仓库：假设在Internet上，为全世界所有Maven工程服务<br>（3）中央仓库镜像：为了分担中央仓库流量，提升用户访问速度</li>
<li>仓库中保存的内容：Maven工程<br>①Maven自身所需要的插件<br>②第三方框架或工具的jar包<br>③我们自己开发的Maven工程<br>不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。</li>
</ol>
<h2 id="12、依赖"><a href="#12、依赖" class="headerlink" title="12、依赖"></a>12、依赖</h2><ol>
<li>当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，这是概念上的描述。Maven解析依赖信息时会到仓库中查找被依赖的jar包。<br>对于我们自己开发的Maven工程，要使用mvn install 命令安装后就可以进入仓库。<br><img src="https://img-blog.csdn.net/20170730165534132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>依赖的范围<br>①从项目结构角度理解compile和test的区别<br><img src="https://img-blog.csdn.net/20170730165755167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>compile范围依赖<br>》对主程序是否有效：有效<br>》对测试程序是否有效：有效<br>》是否参与打包：参与<br>》是否参与部署：参与<br>》典型例子：spring-core<br>test范围依赖<br>》对主程序是否有效：无效<br>》对测试程序是否有效：有效<br>》是否参与打包：不参与<br>》是否参与部署：不参与<br>》典型例子：Junit<br>②从开发和运行这两个阶段理解compile 和 provided 的区别<br><img src="https://img-blog.csdn.net/20170730170327848?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>》对主程序是否有效：有效<br>》对测试程序是否有效：有效<br>》是否参与打包：不参与<br>》是否参与部署：不参与<br>》典型例子：Servlet-api.jar<br>③有效性总结<br><img src="https://img-blog.csdn.net/20170730170652211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>依赖的传递性<br>A依赖B，B依赖C，A能否使用C呢？要看B依赖C的范围是不是compile<br><img src="https://img-blog.csdn.net/20170730171006616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>依赖的排除<br>如果我们当前工程中引入了一个依赖是A，而A又依赖了B，那么Maven会自动将A依赖的B引入当前工程，但是个别情况下B有可能是一个不稳定版本，或对当前工程有不良影响。这时我们可以在引入A的时候将B排除。<br>①情景举例<br><img src="https://img-blog.csdn.net/20170730172241301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>②配置方式<pre><code> &lt;dependency&gt;
 &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;
 &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt;
 &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
 &lt;type&gt;jar&lt;/type&gt;
 &lt;scope&gt;compile&lt;/scope&gt;
 &lt;exclusions&gt;
     &lt; exclusion&gt;
         &lt;groupId&gt;commons-logging&lt;/groupId&gt;
         &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
     &lt;/ exclusion&gt; 
 &lt;/exclusions&gt;
 &lt;/dependency&gt;</code></pre>③排除后的效果<br><img src="https://img-blog.csdn.net/20170730172540566?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>统一管理所依赖 .jar 包的版本<br>对同一个框架的一组jar包最好使用相同的版本。为了方便升级架构，可以将jar包的版本信息统一提取出来<br>①统一声明版本号<br><img src="https://img-blog.csdn.net/20170730173201613?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>其中 atguigu.spring.version 部分是自定义标签。<br>②引用前面声明的版本号<br><img src="https://img-blog.csdn.net/20170730173318435?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><img src="" alt=""><br>③其他用法<br><img src="https://img-blog.csdn.net/20170730173423688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>依赖的原则，解决jar包冲突<br>①路径最短者优先<br><img src="https://img-blog.csdn.net/20170810171428094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>②路径相同时先声明者优先<br><img src="https://img-blog.csdn.net/20170810171449146?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
</ol>
<h2 id="13、生命周期"><a href="#13、生命周期" class="headerlink" title="13、生命周期"></a>13、生命周期</h2><ol>
<li>各个构建环节执行的顺序：不能打乱顺序，必须按照既定的正确顺序来执行。</li>
<li>Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。</li>
<li>Maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中各个阶段：不论现在要执行生命周期中的哪一阶段，都是从这个生命周期最初的位置开始执行。</li>
<li>Maven有三套相互独立的生命周期，分别是：<br>①Clean Lifecycle 在进行真正的构建之前进行一些清理工作。<br>②Default Lifecycle 构建的核心部分，编译、测试、打包、安装、部署等等。<br>③Site Lifecycle 生成项目报告，站点，发布站点。</li>
<li>他们相互独立。也可以直接运行 mvn clean install site 运行所有这三套生命周期。</li>
<li>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。</li>
<li>Clean声明周期<br>①pre-clean 执行一些需要在clean之前完成的工作<br>②clean 移除所有上一次构建生成的文件<br>③post-clean 执行一些需要在clean 之后立刻完成的工作</li>
<li>Default声明周期<br>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：<br>validate<br>generate-sources<br>process-sources<br>generate-resources<br>process-resources 复制并处理资源文件，至目标目录，准备打包。<br>compile 编译项目的源代码。<br>process-classes<br>generate-test-sources<br>process-test-sources<br>generate-test-resources<br>process-test-resources 复制并处理资源文件，至目标测试目录。<br>test-compile 编译测试源代码。<br>process-test-classes<br>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。<br>prepare-package<br>package 接受编译好的代码，打包成可发布的格式，如 JAR。<br>pre-integration-test<br>integration-test<br>post-integration-test<br>verify<br>install 将包安装至本地仓库，以让其它项目依赖。<br>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。</li>
<li>Site生命周期<br>①pre-site 执行一些需要在生成站点文档之前完成的工作<br>②site 生成项目的站点文档<br>③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备<br>④site-deploy 将生成的站点文档部署到特定的服务器上<br>这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。</li>
<li>插件和目标<br>Maven的核心仅仅定义了抽象的声明周期，具体的任务都是交由插件完成的。<br>每个插件都实现多个功能，每个功能就是一个插件目标<br>Maven的生命周期与插件目标相互绑定，以完成某个具体的构建任务。<br>可以将目标看做“调用插件功能的命令”<br>例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。</li>
</ol>
<h2 id="14、在Eclipse中使用Maven"><a href="#14、在Eclipse中使用Maven" class="headerlink" title="14、在Eclipse中使用Maven"></a>14、在Eclipse中使用Maven</h2><ol>
<li>Maven插件Eclipse已经内置。</li>
<li>Maven插件的设置： Window-&gt;Preferences-&gt;Maven<br>①installations : 指定Maven核心程序的位置。默认是插件自带的Maven程序，改为我们自己解压的那个。<br>②user settings : 指定Maven核心程序中 conf/settings.xml 文件的位置，进而获取本地仓库的位置。</li>
<li>基本操作<br>①创建Maven版的Java工程<br>创建时勾选上 Create a simple project(skip archetype selection)<br><img src="https://img-blog.csdn.net/20170810142943257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>创建的Maven工程默认使用的是JDK1.5，打开Maven核心程序settings.xml文件，找到profiles标签，加入如下配置，即可更改 <pre><code> &lt;profile&gt;
     &lt;id&gt;jdk-1.7&lt;/id&gt;
     &lt;activation&gt;
         &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
         &lt;jdk&gt;1.7&lt;/jdk&gt;
     &lt;/activation&gt;
     &lt;properties&gt;
         &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
         &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
         &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt;
     &lt;/properties&gt;
 &lt;/profile&gt;</code></pre>②创建Maven版的Web工程<br>1、New Maven project时，Packaging 选择 war<br><img src="https://img-blog.csdn.net/20170810145801982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>2、调整web目录结构，在项目上点右键 -&gt; properties-&gt;Project Facets -&gt; 把Dynamic Web Module 勾选去掉，并Apply -&gt; 将Dynamic Web Module 重新勾选 -&gt; 点击Further configuration available -&gt; 修改 Content directory为src/main/webapp -&gt; Apply 即在Maven工程上生成动态Web目录结构<br>3、新建jsp文件发现报错：The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path<br>因为缺少Tomcat 运行时环境<br>以Maven方式添加：<br>在pom.xml文件中添加<br><img src="https://img-blog.csdn.net/20170810152056630?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>4、jsp写入EL表达式时发现报错：javax.servlet.jsp cannot be resolved to a type<br>将JSPAPI导入<br>在pom.xml文件中添加<br><img src="https://img-blog.csdn.net/20170810153716289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>注意：scope一定要是provided，不然jar包冲突，运行时会报空指针异常<br>③执行Maven命令<br>选中pom.xml 右键 Run As-&gt;Maven build…-&gt;Goals-&gt;输入 compile -&gt;点击 run</li>
</ol>
<h2 id="15、继承"><a href="#15、继承" class="headerlink" title="15、继承"></a>15、继承</h2><ol>
<li>现状<br>Hello依赖的Junit：4.0<br>HelloFriend依赖的Junit：4.0<br>MakeFriends依赖的Junit：4.9<br>由于test范围的依赖不能传递，所以必然会分散在各个模块工程中，很容易造成版本不一致。</li>
<li>需求：统一管理各个模块工程中对Junit依赖的版本。</li>
<li>解决思路：将Junit依赖统一提取到“父”工程中，在子工程中声明Junit依赖是不指定版本，以父工程中统一设定的为准。同时也便于修改。</li>
<li>操作步骤：<br>①创建一个Maven工程作为父工程。注意：打包方式为pom<br><img src="https://img-blog.csdn.net/20170810175950040?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>②在子工程中声明对父工程的引用<br><img src="https://img-blog.csdn.net/20170810180137704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>③将子工程的坐标中与父工程坐标中重复的内容删除<br><img src="https://img-blog.csdn.net/20170810180306736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>④在父工程中统一管理Junit的依赖<br><img src="https://img-blog.csdn.net/20170810180410293?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>⑤在子工程中删除Junit依赖的版本号部分<br><img src="https://img-blog.csdn.net/20170810180504760?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>注意：配置集成后，执行安装命令时要先安装父工程。</li>
</ol>
<h2 id="16、聚合"><a href="#16、聚合" class="headerlink" title="16、聚合"></a>16、聚合</h2><ol>
<li>作用：一键安装各个模块工程。</li>
<li>配置方式：在一个“总的聚合工程”中配置各个参与聚合的模块<br><img src="https://img-blog.csdn.net/20170810191758989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhtMTMwNjE5Mjk4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>使用方式：在聚合工程的pom.xml 上点右键-&gt;run as-&gt;maven install</li>
</ol>
<h2 id="17、Maven-Web工程的自动部署"><a href="#17、Maven-Web工程的自动部署" class="headerlink" title="17、Maven_Web工程的自动部署"></a>17、Maven_Web工程的自动部署</h2><p>在pom.xml 中添加如下配置：</p>
<pre><code>          &lt;!--配置当前工程构建过程中的特殊设置   --&gt;
          &lt;build&gt;
            &lt;finalName&gt;AtguiguWeb&lt;/finalName&gt;
            &lt;!-- 配置构建过程中需要使用的插件 --&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;!-- cargo是一家专门从事启动Servlet容器的组织 --&gt;
                    &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt;
                    &lt;artifactId&gt;cargo-maven2-plugin&lt;/artifactId&gt;
                    &lt;version&gt;1.2.3&lt;/version&gt;
                    &lt;!-- 针对插件进行的配置 --&gt;
                    &lt;configuration&gt;
                        &lt;!-- 配置当前系统中容器的位置 --&gt;
                        &lt;container&gt;
                            &lt;containerId&gt;tomcat6x&lt;/containerId&gt;
                            &lt;home&gt;D:\DevInstall\apache-tomcat-6.0.39&lt;/home&gt;
                        &lt;/container&gt;
                        &lt;configuration&gt;
                            &lt;type&gt;existing&lt;/type&gt;
                            &lt;home&gt;D:\DevInstall\apache-tomcat-6.0.39&lt;/home&gt;
                            &lt;!-- 如果Tomcat端口为默认值8080则不必设置该属性 --&gt;
                            &lt;properties&gt;
                                &lt;cargo.servlet.port&gt;8989&lt;/cargo.servlet.port&gt;
                            &lt;/properties&gt;
                        &lt;/configuration&gt;
                    &lt;/configuration&gt;
                    &lt;!-- 配置插件在什么情况下执行 --&gt;
                    &lt;executions&gt;  
                        &lt;execution&gt;  
                            &lt;id&gt;cargo-run&lt;/id&gt;
                            &lt;!-- 生命周期的阶段 --&gt;  
                            &lt;phase&gt;install&lt;/phase&gt;  
                            &lt;goals&gt;
                                &lt;!-- 插件的目标 --&gt;  
                                &lt;goal&gt;run&lt;/goal&gt;  
                            &lt;/goals&gt;  
                        &lt;/execution&gt;  
                    &lt;/executions&gt;
                &lt;/plugin&gt;
             &lt;/plugins&gt;
            &lt;/build&gt;</code></pre><p>执行mvn deploy 命令</p>
<h2 id="18、Maven-酷站"><a href="#18、Maven-酷站" class="headerlink" title="18、Maven 酷站"></a>18、Maven 酷站</h2><p>我们可以到 <a href="http://mvnrepository.com/搜索需要的" target="_blank" rel="noopener">http://mvnrepository.com/搜索需要的</a> jar 包的依赖信息。</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>项目开发</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>请求转发和重定向的区别</title>
    <url>/2020/01/16/qing-qiu-zhuan-fa-he-chong-ding-xiang-de-qu-bie/</url>
    <content><![CDATA[<h1 id="请求转发和重定向的区别"><a href="#请求转发和重定向的区别" class="headerlink" title="请求转发和重定向的区别"></a>请求转发和重定向的区别</h1><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="现实生活的例子"><a href="#现实生活的例子" class="headerlink" title="现实生活的例子"></a>现实生活的例子</h3><p><img src="http://qiniuyun.dajienihao.cn/image/0116/%E9%87%8D%E5%AE%9A%E5%90%91.png" alt=""><br>①：A对B说，帮忙拿下快递</p>
<p>②：B对A说，没有空，你找下C吧</p>
<p>③：A对C说，帮忙拿下快递</p>
<p>④：C然后拿了快递给A</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://qiniuyun.dajienihao.cn/image/0116/20180527154555552.png" alt=""></p>
<pre><code>//重定向写法： 重新定位方向 参数即跳转的位置
response.sendRedirect(&quot;login_success.html&quot;);</code></pre><ol>
<li><p>地址上显示的是最后的那个资源的路径地址</p>
</li>
<li><p>请求次数最少有两次， 服务器在第一次请求后，会返回302 以及一个地址， 浏览器在根据这个地址，执行第二次访问。</p>
</li>
<li><p>可以跳转到任意路径。 不是自己的工程也可以跳。</p>
</li>
<li><p>效率稍微低一点， 执行两次请求。 </p>
</li>
<li><p>后续的请求，没法使用上一次的request存储的数据，或者 没法使用上一次的request对象，因为这是两次不同的请求。</p>
</li>
<li><p>重定向访问的可能是外部资源 需要加项目路径${pageContext.request.contextPath}</p>
</li>
</ol>
<h2 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h2><h3 id="现实生活的例子-1"><a href="#现实生活的例子-1" class="headerlink" title="现实生活的例子"></a>现实生活的例子</h3><p><img src="http://qiniuyun.dajienihao.cn/image/0116/%E8%BD%AC%E5%8F%91.png" alt=""><br>①：A对B说，帮忙拿下快递</p>
<p>②：第二步，B没有空，直接找让C帮A拿下快递</p>
<p>③：C拿到了快递并返回给A</p>
<pre><code>//请求转发的写法： 参数即跳转的位置
request.getRequestDispatcher(&quot;login_success.html&quot;).forward(request, response);</code></pre><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://qiniuyun.dajienihao.cn/image/0116/20180527171706259.png" alt=""></p>
<ol>
<li><p>地址上显示的是请求servlet的地址。  返回200 ok</p>
</li>
<li><p>请求次数只有一次， 因为是服务器内部帮客户端执行了后续的工作。 </p>
</li>
<li><p>只能跳转自己项目的资源路径 。  </p>
</li>
<li><p>效率上稍微高一点，因为只执行一次请求。 </p>
</li>
<li><p>可以使用上一次的request对象。 </p>
</li>
<li><p>请求转发路径写内部枯井 无需加项目路径</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>原生JDBC的使用</title>
    <url>/2020/01/13/yuan-sheng-de-jdbc-de-shi-yong/</url>
    <content><![CDATA[<h2 id="JDBC是什么"><a href="#JDBC是什么" class="headerlink" title="JDBC是什么"></a>JDBC是什么</h2><blockquote>
<p>JAVA Database Connectivity java数据库连接</p>
</blockquote>
<h2 id="为什么会出现JDBC"><a href="#为什么会出现JDBC" class="headerlink" title="为什么会出现JDBC"></a>为什么会出现JDBC</h2><blockquote>
<p>SUN公司提供的一种数据库访问规则、规范, 由于数据库种类较多，并且java语言使用比较广泛，sun公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的java程序只要使用sun公司提供的jdbc驱动即可。</p>
</blockquote>
<h2 id="使用JDBC的基本步骤"><a href="#使用JDBC的基本步骤" class="headerlink" title="使用JDBC的基本步骤"></a>使用JDBC的基本步骤</h2><h3 id="1-注册驱动"><a href="#1-注册驱动" class="headerlink" title="1. 注册驱动"></a>1. 注册驱动</h3><pre><code>   DriverManager.registerDriver(new com.mysql.jdbc.Driver());</code></pre><h3 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2. 建立连接"></a>2. 建立连接</h3><pre><code>   //DriverManager.getConnection(&quot;jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb&quot;);
   //建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。
   conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/student&quot;, &quot;root&quot;, &quot;root&quot;);</code></pre><h3 id="3-创建statement"><a href="#3-创建statement" class="headerlink" title="3. 创建statement"></a>3. 创建statement</h3><pre><code>   //创建statement ， 跟数据库打交道，一定需要这个对象
   st = conn.createStatement();</code></pre><h3 id="4-执行sql-，得到ResultSet"><a href="#4-执行sql-，得到ResultSet" class="headerlink" title="4. 执行sql ，得到ResultSet"></a>4. 执行sql ，得到ResultSet</h3><pre><code>   //执行查询 ， 得到结果集
   String sql = &quot;select * from t_stu&quot;;
   rs = st.executeQuery(sql);</code></pre><h3 id="5-遍历结果集"><a href="#5-遍历结果集" class="headerlink" title="5. 遍历结果集"></a>5. 遍历结果集</h3><pre><code>   //遍历查询每一条记录
       while(rs.next()){
           int id = rs.getInt(&quot;id&quot;);
           String name = rs.getString(&quot;name&quot;);
           int age = rs.getInt(&quot;age&quot;);
           System.out.println(&quot;id=&quot;+id + &quot;===name=&quot;+name+&quot;==age=&quot;+age);    
       }</code></pre><h3 id="6-释放资源"><a href="#6-释放资源" class="headerlink" title="6. 释放资源"></a>6. 释放资源</h3><pre><code>    if (rs != null) {
        try {
            rs.close();
        } catch (SQLException sqlEx) { } // ignore 
        rs = null;
    }
    ...</code></pre><h2 id="JDBC-工具类构建"><a href="#JDBC-工具类构建" class="headerlink" title="JDBC 工具类构建"></a>JDBC 工具类构建</h2><h3 id="1-资源释放工作的整合"><a href="#1-资源释放工作的整合" class="headerlink" title="1. 资源释放工作的整合"></a>1. 资源释放工作的整合</h3><h3 id="2-驱动防二次注册"><a href="#2-驱动防二次注册" class="headerlink" title="2. 驱动防二次注册"></a>2. 驱动防二次注册</h3><pre><code>   DriverManager.registerDriver(new com.mysql.jdbc.Driver());
   Driver 这个类里面有静态代码块，一上来就执行了，所以等同于我们注册了两次驱动。 其实没这个必要的。
   //静态代码块 ---&gt; 类加载了，就执行。 java.sql.DriverManager.registerDriver(new Driver());
    最后形成以下代码即可。
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);    </code></pre><h3 id="3-使用properties配置文件"><a href="#3-使用properties配置文件" class="headerlink" title="3. 使用properties配置文件"></a>3. 使用properties配置文件</h3><ol>
<li>在src底下声明一个文件 xxx.properties ，里面的内容吐下：<pre><code>   driverClass=com.mysql.jdbc.Driver
   url=jdbc:mysql://localhost/student
   name=root
   password=root</code></pre></li>
<li>在工具类里面，使用静态代码块，读取属性<pre><code> static{
     try {
         //1. 创建一个属性配置对象
         Properties properties = new Properties();
         InputStream is = new FileInputStream(&quot;jdbc.properties&quot;); //对应文件位于工程根目录
         //使用类加载器，去读取src底下的资源文件。 后面在servlet  //对应文件位于src目录底下
         //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
         //导入输入流。
         properties.load(is);
         //读取属性
         driverClass = properties.getProperty(&quot;driverClass&quot;);
         url = properties.getProperty(&quot;url&quot;);
         name = properties.getProperty(&quot;name&quot;);
         password = properties.getProperty(&quot;password&quot;);
     } catch (Exception e) {
         e.printStackTrace();
     }
 }</code></pre></li>
</ol>
<h2 id="数据库的CRUD-sql"><a href="#数据库的CRUD-sql" class="headerlink" title="数据库的CRUD sql"></a>数据库的CRUD sql</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><pre><code>  INSERT INTO t_stu (NAME , age) VALUES (&#39;wangqiang&#39;,28)
    INSERT INTO t_stu VALUES (NULL,&#39;wangqiang2&#39;,28)
        // 1. 获取连接对象
        conn = JDBCUtil.getConn();
        // 2. 根据连接对象，得到statement
        st = conn.createStatement();
        //3. 执行添加
        String sql = &quot;insert into t_stu values(null , &#39;aobama&#39; , 59)&quot;;
        //影响的行数， ，如果大于0 表明操作成功。 否则失败
        int result = st.executeUpdate(sql);
        if(result &gt;0 ){
            System.out.println(&quot;添加成功&quot;);
        }else{
            System.out.println(&quot;添加失败&quot;);
        }</code></pre><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><pre><code>  DELETE FROM t_stu WHERE id = 6
        // 1. 获取连接对象
        conn = JDBCUtil.getConn();
        // 2. 根据连接对象，得到statement
        st = conn.createStatement();
        //3. 执行添加
        String sql = &quot;delete from t_stu where name=&#39;aobama&#39;&quot;;
        //影响的行数， ，如果大于0 表明操作成功。 否则失败
        int result = st.executeUpdate(sql);
        if(result &gt;0 ){
            System.out.println(&quot;删除成功&quot;);
        }else{
            System.out.println(&quot;删除失败&quot;);
        }</code></pre><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><pre><code>  SELECT * FROM t_stu
        // 1. 获取连接对象
        conn = JDBCUtil.getConn();
        // 2. 根据连接对象，得到statement
        st = conn.createStatement();
        // 3. 执行sql语句，返回ResultSet
        String sql = &quot;select * from t_stu&quot;;
        rs = st.executeQuery(sql);
        // 4. 遍历结果集
        while (rs.next()) {
            String name = rs.getString(&quot;name&quot;);
            int age = rs.getInt(&quot;age&quot;);
            System.out.println(name + &quot;   &quot; + age);
        }</code></pre><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><pre><code>  UPDATE t_stu SET age = 38 WHERE id = 1;
        // 1. 获取连接对象
        conn = JDBCUtil.getConn();
        // 2. 根据连接对象，得到statement
        st = conn.createStatement();
        //3. 执行添加
        String sql = &quot;update t_stu set age = 26 where name =&#39;qyq&#39;&quot;;
        //影响的行数， ，如果大于0 表明操作成功。 否则失败
        int result = st.executeUpdate(sql);
        if(result &gt;0 ){
            System.out.println(&quot;更新成功&quot;);
        }else{
            System.out.println(&quot;更新失败&quot;);
        }</code></pre><h2 id="使用单元测试，测试代码"><a href="#使用单元测试，测试代码" class="headerlink" title="使用单元测试，测试代码"></a>使用单元测试，测试代码</h2><ol>
<li><p>定义一个类， TestXXX , 里面定义方法 testXXX.</p>
</li>
<li><p>添加junit的支持。 </p>
<pre><code>右键工程 --- add Library --- Junit --- Junit4</code></pre></li>
<li><p>在方法的上面加上注解 ， 其实就是一个标记。</p>
<pre><code>@Test
public void testQuery() {
    ...
}</code></pre></li>
<li><p>光标选中方法名字，然后右键执行单元测试。  或者是打开outline视图， 然后选择方法右键执行。</p>
</li>
</ol>
<h2 id="Dao模式"><a href="#Dao模式" class="headerlink" title="Dao模式"></a>Dao模式</h2><blockquote>
<p>Data Access Object 数据访问对象</p>
</blockquote>
<ol>
<li>新建一个dao的接口， 里面声明数据库访问规则</li>
</ol>
<pre><code>    /**
     * 定义操作数据库的方法
     */
    public interface UserDao {
        /**
         * 查询所有
         */
        void findAll();
    }</code></pre><ol start="2">
<li>新建一个dao的实现类，具体实现早前定义的规则</li>
</ol>
<pre><code>    public class UserDaoImpl implements UserDao{
    @Override
    public void findAll() {
        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;
        try {
            //1. 获取连接对象
            conn = JDBCUtil.getConn();
            //2. 创建statement对象
            st = conn.createStatement();
            String sql = &quot;select * from t_user&quot;;
            rs = st.executeQuery(sql);        
            while(rs.next()){
                String userName = rs.getString(&quot;username&quot;);
                String password = rs.getString(&quot;password&quot;);
                System.out.println(userName+&quot;=&quot;+password);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            JDBCUtil.release(conn, st, rs);
        }
    }
}</code></pre><ol start="3">
<li>直接使用实现<br> @Test<br> public void testFindAll(){<br> UserDao dao = new UserDaoImpl();<pre><code> dao.findAll();</code></pre> }</li>
</ol>
<h2 id="Statement的安全问题"><a href="#Statement的安全问题" class="headerlink" title="Statement的安全问题"></a>Statement的安全问题</h2><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>Statement执行 ，其实是拼接sql语句的。  先拼接sql语句，然后在一起执行。 </p>
<pre><code>    String sql = &quot;select * from t_user where username=&#39;&quot;+ username  +&quot;&#39; and password=&#39;&quot;+ password +&quot;&#39;&quot;;

    UserDao dao = new UserDaoImpl();
    dao.login(&quot;admin&quot;, &quot;100234khsdf88&#39; or &#39;1=1&quot;);

    SELECT * FROM t_user WHERE username=&#39;admin&#39; AND PASSWORD=&#39;100234khsdf88&#39; or &#39;1=1&#39; 

    前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 
    rs = st.executeQuery(sql);</code></pre><h3 id="PrepareStatement"><a href="#PrepareStatement" class="headerlink" title="PrepareStatement"></a>PrepareStatement</h3><p>该对象就是替换前面的statement对象。<br>相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。</p>
<pre><code>         String sql = &quot;insert into t_user values(null , ? , ?)&quot;;
         ps = conn.prepareStatement(sql);
         //给占位符赋值 从左到右数过来，1 代表第一个问号， 永远你是1开始。
         ps.setString(1, userName);
         ps.setString(2, password);</code></pre><p>​    </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>JDBC入门</li>
<li>抽取工具类  </li>
<li>Statement CRUD 演练crud</li>
<li>Dao模式  声明与实现分开</li>
<li>PrepareStament 预处理sql语句，解决上面statement出现的问题</li>
</ol>
]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>原生JDBC的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓自定义view五子棋项目</title>
    <url>/2019/12/29/an-zhuo-zi-ding-yi-view-wu-zi-qi-xiang-mu-xiang-xi/</url>
    <content><![CDATA[<p>当初学编程的，都想做一个游戏，俄罗斯方块？贪吃蛇？不不不，今天我所讲的是五子棋双人对战，对比那些来说，应该算比较简单的了。<br>相信很多人都有看过，不过视频中，我发现有些代码是不需要的，而且还存在一些bug，针对视频所存在的bug我都做了调整，经测试，目前无bug。<br>创建一个类，然后继承View，需要实现构造方法，我们选择两个参数的构造方法就行了<br>下面贴出代码：</p>
<pre><code>public panel(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();//初始化方法
    }</code></pre><p>所需定义的内容：</p>
<pre><code>private int mPanelWidth;
private float mLineHeight;//棋盘行距
private int MAX_LINE = 10;//棋盘行数
private Paint mPaint = new Paint();//绘制对象
private Bitmap mWhitePiece;//白色棋子
private Bitmap mBlackPiece;//黑色棋子
private boolean mIsWhite = true;//白棋先手，当前轮到白棋出子
private List&lt;Point&gt; mWhiteArray = new ArrayList&lt;&gt;();//放白色棋子落子的坐标
private List&lt;Point&gt; mBlackArray = new ArrayList&lt;&gt;();//放黑色棋子落子的坐标
private float ratioPieceOfLineHeight = 3 * 1.0f / 4;//棋子占据的比例
private boolean mIsGameOver;//判断游戏结束
private boolean mIsWhiteWinner;//true白子胜利，false黑子胜利
private int MAX_COUNT_IN_LINE = 5;//五子棋数</code></pre><p>  对画笔的初始化：</p>
<pre><code> private void init() {//初始化方法
        mPaint.setColor(Color.rgb(0, 0, 0));//设置颜色
        mPaint.setAntiAlias(true);//抗锯齿
        mPaint.setDither(true);//设置防抖动
        mPaint.setStyle(Paint.Style.STROKE);//绘制棋盘线条，画笔为描边样式
        mWhitePiece = BitmapFactory.decodeResource(getResources(), R.drawable.stone_w2);//设置白色棋子图片
        mBlackPiece = BitmapFactory.decodeResource(getResources(), R.drawable.stone_b1);//设置黑色棋子图片
    }</code></pre><p> 对于自定义view有一定基础的小伙伴都知道，自定义一般都要实现2个方法，1：onSizeChanged（视图大小的改变）；2：onMeasure（告诉父view，子视图占用多大的空间）<br>下面上代码，我都有详细注解，就不一个一个解释了：<br>onMeasure：</p>
<pre><code>    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {//设置棋盘大小
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);//获取宽度
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);//根据测量值提取模式
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);//获取高度
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);//根据测量值提取模式
        int width = Math.min(widthSize, heightSize);//取最小值获取设置正方形棋盘
        if (widthMode == MeasureSpec.UNSPECIFIED)//当模式为未指定模式时就为棋盘长宽就为高度
            width = heightSize;
        else if (heightMode == MeasureSpec.UNSPECIFIED)//当模式为未指定模式时就为棋盘长宽就为宽度
            width = widthSize;
        setMeasuredDimension(width, width);//取宽高的最小值绘制棋盘
    }</code></pre><p> onSizeChanged：</p>
<pre><code> protected void onSizeChanged(int w, int h, int oldw, int oldh) {//当宽高发生改变进行回调
        super.onSizeChanged(w, h, oldw, oldh);
        mPanelWidth = w;
        mLineHeight = mPanelWidth * 1.0f / MAX_LINE;//棋盘行距
        int pieceWidth = (int) (mLineHeight * ratioPieceOfLineHeight);//棋子比列
        mWhitePiece = Bitmap.createScaledBitmap(mWhitePiece, pieceWidth, pieceWidth, false);//设置棋子大小
        mBlackPiece = Bitmap.createScaledBitmap(mBlackPiece, pieceWidth, pieceWidth, false);//设置棋子大小
    }</code></pre><p> 好了，下面我们进图画图操作，需要的操作是，先画棋盘，在画棋子，然后判断游戏结束。</p>
<pre><code>  protected void onDraw(Canvas canvas) {//绘制方法
        super.onDraw(canvas);
        drawBoard(canvas);//绘制棋盘
        drawPiece(canvas);//绘制棋子
        checkGameOver();//检查游戏是否结束
    }</code></pre><p> 绘制棋盘：</p>
<pre><code>  private void drawBoard(Canvas canvas) {//绘制棋盘方法
        int w = mPanelWidth;//棋盘宽度
        float lineHeight = mLineHeight;//棋盘行距
        for (int i = 0; i &lt; MAX_LINE; i++) {
            int startX = (int) (lineHeight / 2);//起点坐标
            int endX = (int) (w - lineHeight / 2);//终点坐标
            int y = (int) ((0.5 + i) * lineHeight);//y轴起点坐标
            canvas.drawLine(startX, y, endX, y, mPaint);//绘制x轴线条
            canvas.drawLine(y, startX, y, endX, mPaint);//绘制y轴线条
        }
    }</code></pre><p>绘制棋子：</p>
<pre><code>private void drawPiece(Canvas canvas) {//绘制棋子方法
        for (int i = 0; i &lt; mWhiteArray.size(); i++) {
            Point whitePoint = mWhiteArray.get(i);//拿到棋子
            canvas.drawBitmap(mWhitePiece,
                    (whitePoint.x + (1 - ratioPieceOfLineHeight) / 2) * mLineHeight,
                    (whitePoint.y + (1 - ratioPieceOfLineHeight) / 2) * mLineHeight, null);//棋子坐标计算
        }
        for (int i = 0; i &lt; mBlackArray.size(); i++) {
            Point blackPoint = mBlackArray.get(i);//拿到棋子
            canvas.drawBitmap(mBlackPiece,
                    (blackPoint.x + (1 - ratioPieceOfLineHeight) / 2) * mLineHeight,
                    (blackPoint.y + (1 - ratioPieceOfLineHeight) / 2) * mLineHeight, null);//棋子坐标计算
        }
    }</code></pre><p>判断游戏是否结束:</p>
<pre><code>private void checkGameOver() {//判断游戏是否结束及和棋
        boolean whiteWin = checkFiveInLine(mWhiteArray);//白子成功五子连珠
        boolean blackWin = checkFiveInLine(mBlackArray);//黑子成功五子连珠
        int max = MAX_LINE * MAX_LINE;//最大落子数的和
        if (whiteWin || blackWin) {//有人胜利
            mIsGameOver = true;//游戏结束
            mIsWhiteWinner = whiteWin;
            String text = mIsWhiteWinner ? &quot;白棋胜利&quot; : &quot;黑棋胜利&quot;;//白子赢了提示白棋胜利，否者黑棋胜利
            if (mIsGameOver) {
                AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
                builder.setIcon(R.drawable.dy);
                builder.setTitle(&quot;游戏结束，&quot; + text);
                builder.setMessage(&quot;请选项下面选项！！！！&quot;);
                builder.setNegativeButton(&quot;退出游戏&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        System.exit(0);
                    }
                });
                builder.setNeutralButton(&quot;查看棋盘！&quot;, new DialogInterface.OnClickListener() {

                    public void onClick(DialogInterface dialogInterface, int i) {
                        dialogInterface.dismiss();
                    }
                });
                builder.setPositiveButton(&quot;再来一局&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        reStart();
                    }
                });
                builder.setCancelable(false);
                builder.show();
            }
        } else if ((mBlackArray.size() + mWhiteArray.size()) == max) {//当白棋子数和黑棋字数相加等于最大数时无人胜利，双方和棋
            AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
            builder.setIcon(R.drawable.dy);
            builder.setTitle(&quot;棋逢对手,将遇良才！&quot;);
            builder.setMessage(&quot;二位和棋，是否再战一句！！！&quot;);
            builder.setNegativeButton(&quot;退出游戏&quot;, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    System.exit(0);
                }
            });
            builder.setNeutralButton(&quot;查看棋盘！&quot;, new DialogInterface.OnClickListener() {

                public void onClick(DialogInterface dialogInterface, int i) {
                    dialogInterface.dismiss();
                }
            });
            builder.setPositiveButton(&quot;再来一局&quot;, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    reStart();
                }
            });
            builder.setCancelable(false);
            builder.show();
        }
    }</code></pre><p>游戏结束的判断的依据：</p>
<pre><code>private boolean checkFiveInLine(List&lt;Point&gt; points) {//判断是否五子连珠
        for (Point p : points) {
            int x = p.x;
            int y = p.y;
            boolean win = checkHorizontal(x, y, points);//判断xy位置的棋子是否有左右相邻的五个一致
            if (win)
                return true;
            win = checkVertiacal(x, y, points);//判断xy位置的棋子是否有上下相邻的五个一致
            if (win)
                return true;
            win = checkLeftDiagonal(x, y, points);//判断xy位置的棋子是否有左斜相邻的五个一致
            if (win)
                return true;
            win = checkRightDiagonal(x, y, points);//判断xy位置的棋子是否有右斜相邻的五个一致
            if (win)
                return true;
        }
        return false;
    }</code></pre><p>判断是否有横向五子连珠：</p>
<pre><code>private boolean checkHorizontal(int x, int y, List&lt;Point&gt; points) {//判断x，y位置的棋子是否有横向相邻的五个一致
        int count = 1;//当前子
        for (int i = 1; i &lt; MAX_COUNT_IN_LINE; i++) {//从当前子往左数最大4个，如果有相同子count加1
            if (points.contains(new Point(x - i, y))) {
                count++;
            } else {
                break;
            }
        }
        if (count == MAX_COUNT_IN_LINE)//如果count为5表示成功连珠
            return true;


        for (int i = 1; i &lt; MAX_COUNT_IN_LINE; i++) {//从当前子往右数最大4个，如果有相同子count加1
            if (points.contains(new Point(x + i, y))) {
                count++;
            } else {
                break;
            }
        }
        if (count == MAX_COUNT_IN_LINE)//如果count为5表示成功连珠
            return true;
        return false;
    }</code></pre><p>其他方向的代码和上面一样只是循环中x，y的值改一下，就不放具体代码了，具体提示一下竖向判断的(x,y-1),(x,y+1）左斜是(x - i, y + i),(x + i, y - i) 右斜是(x - i, y - i),(x + i, y + i)<br>重新开始游戏:</p>
<pre><code>public void reStart() {//重新开始游戏
        mWhiteArray.clear();
        mBlackArray.clear();
        mIsGameOver = false;
        mIsWhiteWinner = false;
        mIsWhite=true;
        invalidate();
    }</code></pre><p>悔棋：</p>
<pre><code>public void withDraw() {//悔棋
        if (mIsGameOver) {
            Toast.makeText(getContext(), &quot;游戏已经结束，不能悔棋&quot;, Toast.LENGTH_LONG).show();
            return;
        }
        if (mBlackArray.size() &gt; 0 || mWhiteArray.size() &gt; 0) {
            if (mIsWhite) {
                mBlackArray.remove(mBlackArray.size() - 1);
                mIsWhite = !mIsWhite;
            } else {
                mWhiteArray.remove(mWhiteArray.size() - 1);
                mIsWhite = !mIsWhite;
            }
            invalidate();
        }
    }</code></pre><p>这里我没有考虑到禁手的问题，感觉如果考虑到禁手的话，算法比较复杂，人机对战。这里呢此类的代码就完成了<br>下面将布局代码发出来</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;
    android:background=&quot;@drawable/bg&quot;&gt;
    &lt;TextView
        android:id=&quot;@+id/textview&quot;
        android:textColor=&quot;#000000&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:textSize=&quot;30dp&quot;
        android:layout_centerHorizontal=&quot;true&quot;
        android:layout_above=&quot;@id/wuziqi&quot;
        /&gt;
    &lt;com.example.myapplication.panel
        android:id=&quot;@+id/wuziqi&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_centerInParent=&quot;true&quot; /&gt;
    &lt;LinearLayout
        android:layout_below=&quot;@id/wuziqi&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_marginLeft=&quot;60dp&quot;
        android:layout_marginRight=&quot;60dp&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;Button
            android:id=&quot;@+id/restart&quot;
            android:text=&quot;重新开始&quot;
            android:onClick=&quot;reStart&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;/&gt;
        &lt;TextView
            android:layout_weight=&quot;1&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;&quot;/&gt;
        &lt;Button
            android:id=&quot;@+id/withdraw&quot;
            android:text=&quot;悔棋&quot;
            android:onClick=&quot;withdraw&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;/&gt;
    &lt;/LinearLayout&gt;
&lt;/RelativeLayout&gt;</code></pre><p>mainactivity.java文件的代码也发出来</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    panel panel;
    TextView textView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        panel=findViewById(R.id.wuziqi);
    }

    public void reStart(View view) {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setIcon(R.drawable.dy);
        builder.setTitle(&quot;重新开始&quot;);
        builder.setMessage(&quot;重新开始游戏需要双方棋手同意请选择！！！&quot;);
        builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

            }
        });
        builder.setPositiveButton(&quot;重新开始&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                panel.reStart();
            }
        });
        builder.setCancelable(false);
        builder.show();
    }

    public void withdraw(View view) {

        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setIcon(R.drawable.dy);
        builder.setTitle(&quot;悔棋&quot;);
        builder.setMessage(&quot;悔棋需要双方棋手同意请选择！！！&quot;);
        builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

            }
        });
        builder.setPositiveButton(&quot;确定悔棋&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                panel.withDraw();
            }
        });
        builder.setCancelable(false);
        builder.show();
    }
}</code></pre><p>好了到这里安卓五子棋的项目就完成了，自定义view的难度在于给viwe的大小及测量，完成这些的话其实自定义view并没有这么难。</p>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>自定义view</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的索引</title>
    <url>/2019/12/21/mysql-de-suo-yin/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>在数据库操作中，经常需要查询特定的数据，例如，当执行<code>select * from student where id=10000</code>语句时，MySQL数据库必须从第一条记录开始遍历，直到找出id为10000的数据，这样的效率显然非常低。为此，MySQL允许建立索引来加快数据表的查询和排序。</p>
<h2 id="1-索引的概念"><a href="#1-索引的概念" class="headerlink" title="1.索引的概念"></a>1.索引的概念</h2><p>数据库的索引好比新华字典的音序表，它是对数据库表中一列或多列的值进行排序后的一种结构，其作用就是提高表中数据的查询进度。MySQL的索引分为很多种，具体如下：</p>
<h3 id="1-1普通索引"><a href="#1-1普通索引" class="headerlink" title="1.1普通索引"></a>1.1普通索引</h3><p>普通索引是由<code>key或index</code>定义的索引，他是mysql中的基本索引类型，可以创建在任何数据类型中，其值是否唯一和非空由字段本身的约束条件决定。例如，在grade表的stu_id字段上建立一个普通索引，查询记录时，就可以根据该索引进行查询了。</p>
<h3 id="1-2唯一性索引"><a href="#1-2唯一性索引" class="headerlink" title="1.2唯一性索引"></a>1.2唯一性索引</h3><p>唯一性索引是由<code>UNIQUE</code>定义的索引，该索引所在的字段必须是唯一的。例如，在grade表的id字段建立唯一性索引，那么，id字段的值就必须是唯一的。</p>
<h3 id="1-3全文索引"><a href="#1-3全文索引" class="headerlink" title="1.3全文索引"></a>1.3全文索引</h3><p>全文索引是由<code>FULLTEXT</code>定义的索引，他只能创建在<code>char、varchar或text</code>类型上的字段上，而且只有<code>MYISAM</code>存储引擎支持全文索引。</p>
<h3 id="1-4单列索引"><a href="#1-4单列索引" class="headerlink" title="1.4单列索引"></a>1.4单列索引</h3><p>单列索引指得是在表中单个字段上创建索引，它可以是普通索引、唯一索引或全文索引，只要保证该索引对应表中的一个字段即可。</p>
<h3 id="1-5空间索引"><a href="#1-5空间索引" class="headerlink" title="1.5空间索引"></a>1.5空间索引</h3><p>空间索引是由<code>SPATIAL</code>定义的索引，他只能创建在空间数据类型的字段上，MySQL的空间数据类型有四种，分别是<code>GEOMETRY、POINT、LINESTRING和POLYGON</code>。需要注意的是，创建空间索引的字段，必须将其声明为<code>NOT NULL</code>，并且空间索引只能在<code>MYISAM</code>的表创建。</p>
<blockquote>
<p>需要注意的是，虽然索引可以提高数据的查询速度，但索引会占据一定的磁盘空间，并且在创建和维护索引时，其消耗的时间是随着数据量的增加而增加的。因此使用索引时，应该综合考虑索引的优点和缺点。</p>
</blockquote>
<h2 id="2-创建索引"><a href="#2-创建索引" class="headerlink" title="2.创建索引"></a>2.创建索引</h2><p>要想使用索引提高数据表的查询速度，首先要创建一个索引。创建索引的方法有三种，具体如下。</p>
<h3 id="2-1创建表的时候创建索引"><a href="#2-1创建表的时候创建索引" class="headerlink" title="2.1创建表的时候创建索引"></a>2.1创建表的时候创建索引</h3><p>创建表的时候可以直接创建索引，这中方式最简单、方便，其基本的语法格式如下所示：</p>
<pre><code>create table 表名(字段名 数据类型 [完整约束条件]，
                  字段名 数据类型 [完整约束条件]，
                  ...
                      字段名 数据类型 
                      [UNIQUE|FULLTEXT|SPATIAL] INDEX｜KEY 
                          [别名](字段名1 [(长度)] [ASC]|[DESC])，
）；</code></pre><p>关于上述语法的相关解释具体如下。</p>
<ol>
<li>UNIQUE：可选参数，表示唯一索引。</li>
<li>FULLTEXT：可选参数，表示全文索引。</li>
<li>SPATIAL：可选参数，表示空间索引。</li>
<li>INDEX和KEY：用来表示字段的索引，二选一即可。</li>
<li>别名：可选参数，表示创建的索引名称。</li>
<li>字段名1：指定索引对应字段的名称。</li>
<li>长度：可选参数，用于表示索引的长度。</li>
<li>ASC和DESC：可选参数，其中ASC表示升序排列，DESC表示降序排列。</li>
</ol>
<p>为了帮助读者更好地了解如何在创建表的时候创建索引，接下来，通过具体的案例，分别对MySQL的六种索引类型进行详解，具体如下：</p>
<h4 id="2-1-1-创建普通索引"><a href="#2-1-1-创建普通索引" class="headerlink" title="2.1.1 创建普通索引"></a>2.1.1 创建普通索引</h4><pre><code>create table t1(id int，
                name varchar(20),
                score float,
                INDEX (name)
);</code></pre><h4 id="2-1-2-创建唯一性索引"><a href="#2-1-2-创建唯一性索引" class="headerlink" title="2.1.2 创建唯一性索引"></a>2.1.2 创建唯一性索引</h4><pre><code>create table t2(id int not null,
                name varchar(20) not null,
                score float,
                unique index unique_id(id Asc)
);</code></pre><h4 id="2-1-3-创建全文索引"><a href="#2-1-3-创建全文索引" class="headerlink" title="2.1.3 创建全文索引"></a>2.1.3 创建全文索引</h4><pre><code>create table t3(id int not null,
                name varchar(20) not null,
                score float,
                fulltext index fulltext_name(name)
)engine=myisam;</code></pre><h4 id="2-1-4-创建单列索引"><a href="#2-1-4-创建单列索引" class="headerlink" title="2.1.4 创建单列索引"></a>2.1.4 创建单列索引</h4><pre><code>create table t4(id int not null,
                name varchar(20) not null,
                score float,
                index single_name(name(20))
);</code></pre><h4 id="2-1-5-创建多列索引"><a href="#2-1-5-创建多列索引" class="headerlink" title="2.1.5 创建多列索引"></a>2.1.5 创建多列索引</h4><pre><code>create table t5(id int not null,
                name varchar(20) not null,
                score float,
                index multi(name(20),id)
);</code></pre><h4 id="2-1-6-创建空间索引"><a href="#2-1-6-创建空间索引" class="headerlink" title="2.1.6 创建空间索引"></a>2.1.6 创建空间索引</h4><pre><code>create table t6(id int,
                space GEOMETRY not null,
                SPATIAL index sp(space）
)engine=myisam；</code></pre><h3 id="2-2-创建使用create-index语句在已存在的表上创建索引"><a href="#2-2-创建使用create-index语句在已存在的表上创建索引" class="headerlink" title="2.2 创建使用create index语句在已存在的表上创建索引"></a>2.2 创建使用create index语句在已存在的表上创建索引</h3><p>若想在一个已经存在的表上创建索引，可以使用<code>create index语句，create index</code>语句创建索引的具体语法格式如下所示：</p>
<pre><code>create [UNIQUE|FULLTEXT|SPATIAL] index 索引名
on 表名 （字段名 [(长度)] [ASC|DESC]);</code></pre><p>在上述语法中<code>UNIUE、FULLTEXT和SPATIAL</code>都是可选参数，分别用于表示唯一性索引、全文索引和空间索引；index用于指明字段为索引。<br>为了便于学习如何使用<code>create index</code>语句在已经存在的表创建索引，接下来创建一个book表，该表中没有任何的索引，创建book表的sql语句如下所示：</p>
<pre><code>create table book(
                bookid int not null,
                bookname varchar(255) not null,
                authors varchar(255) not null,
                info varchar(255) null,
                comment varchar(255) null,
                publicyear year not null
);</code></pre><h4 id="2-2-1-创建普通索引"><a href="#2-2-1-创建普通索引" class="headerlink" title="2.2.1 创建普通索引"></a>2.2.1 创建普通索引</h4><p><code>create index index_id on book (bookid);</code></p>
<h4 id="2-2-2-创建唯一性索引"><a href="#2-2-2-创建唯一性索引" class="headerlink" title="2.2.2 创建唯一性索引"></a>2.2.2 创建唯一性索引</h4><p><code>create unique index uniqueidx on book (bookid);</code></p>
<h4 id="2-2-3-创建单列索引"><a href="#2-2-3-创建单列索引" class="headerlink" title="2.2.3 创建单列索引"></a>2.2.3 创建单列索引</h4><p><code>create index singleidx on book(comment);</code></p>
<h4 id="2-2-4-创建多列索引"><a href="#2-2-4-创建多列索引" class="headerlink" title="2.2.4 创建多列索引"></a>2.2.4 创建多列索引</h4><p><code>create index mulitidx on book(authors(20),info(20));</code></p>
<h4 id="2-2-5-创建全文索引"><a href="#2-2-5-创建全文索引" class="headerlink" title="2.2.5 创建全文索引"></a>2.2.5 创建全文索引</h4><p><code>create fulltext index fulltextidx on book(info);</code></p>
<h4 id="2-2-6-创建空间索引"><a href="#2-2-6-创建空间索引" class="headerlink" title="2.2.6 创建空间索引"></a>2.2.6 创建空间索引</h4><p><code>create SPATIAL index spatidx on t7(g);</code></p>
<h3 id="2-3-使用alter-table-语句在已经存在的表上创建索引"><a href="#2-3-使用alter-table-语句在已经存在的表上创建索引" class="headerlink" title="2.3 使用alter table 语句在已经存在的表上创建索引"></a>2.3 使用alter table 语句在已经存在的表上创建索引</h3><p>在已经存在的表上创建索引，除了可以使用<code>create index</code>语句外，还可以使用<code>alter table</code>语句。使用<code>alter table</code>语句创建索引的语法格式如下所示：</p>
<pre><code>alter table 表名 add [UNIQUE|FULLTEXT|SPATIAL] index
                索引名 （字段名 [(长度)] [ASC|DESC])</code></pre><p>在上述语法中<code>UNIUE、FULLTEXT和SPATIAL</code>都是可选参数，分别用于表示唯一性索引、全文索引和空间索引；add表示像表中添加字段。<br>接下类同样以book表为例，对不同类型的索引进行详解。</p>
<h4 id="2-3-1-创建普通索引"><a href="#2-3-1-创建普通索引" class="headerlink" title="2.3.1 创建普通索引"></a>2.3.1 创建普通索引</h4><p><code>alter table book add index index_id(bookid);</code></p>
<h4 id="2-3-2-创建唯一性索引"><a href="#2-3-2-创建唯一性索引" class="headerlink" title="2.3.2 创建唯一性索引"></a>2.3.2 创建唯一性索引</h4><p><code>alter table book add unique uniqueidx(bookid);</code></p>
<h4 id="2-3-3-创建单列索引"><a href="#2-3-3-创建单列索引" class="headerlink" title="2.3.3 创建单列索引"></a>2.3.3 创建单列索引</h4><p><code>alter table book add index singleidx (comment(50));</code></p>
<h4 id="2-3-4-创建多列索引"><a href="#2-3-4-创建多列索引" class="headerlink" title="2.3.4 创建多列索引"></a>2.3.4 创建多列索引</h4><p><code>alter table book add index multidx(autros(50),info(50));</code></p>
<h4 id="2-3-5-创建全文索引"><a href="#2-3-5-创建全文索引" class="headerlink" title="2.3.5 创建全文索引"></a>2.3.5 创建全文索引</h4><p><code>alter table book add fulltext index fulltextidx(info);</code></p>
<h4 id="2-3-6-创建空间索引"><a href="#2-3-6-创建空间索引" class="headerlink" title="2.3.6 创建空间索引"></a>2.3.6 创建空间索引</h4><p><code>alter table t8 add spatial index spatidx(space);</code></p>
<h2 id="3-删除索引"><a href="#3-删除索引" class="headerlink" title="3.删除索引"></a>3.删除索引</h2><p>由于索引会占用一定的磁盘空间，因此，为了避免影响数据库性能，应该及时删除不在使用的索引。删除索引的方式有两种，具体如下:</p>
<h3 id="3-1使用alter-table删除索引"><a href="#3-1使用alter-table删除索引" class="headerlink" title="3.1使用alter table删除索引"></a>3.1使用alter table删除索引</h3><p>使用<code>alter table``删除索引的基本语法格式如下所示：</code>alter table 表名 drop index 索引名```</p>
<pre><code>alter table book index fulltextidx；</code></pre><h3 id="3-2使用drop-index删除索引"><a href="#3-2使用drop-index删除索引" class="headerlink" title="3.2使用drop index删除索引"></a>3.2使用drop index删除索引</h3><p>使用<code>drop index</code> 删除索引的基本语法格式如下：<br><code>drop index 索引名 on 表名；</code></p>
<pre><code>drop index spatidx on t8;</code></pre>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql表的约束</title>
    <url>/2019/12/18/biao-de-yue-shu/</url>
    <content><![CDATA[<h2 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h2><p>为了防止数据表中插入错误的数据，在mysql中定义了一些维护数据库完整性的规则，即表的约束。<br><img src="http://qiniuyun.dajienihao.cn/image/1218/%E8%A1%A8%E7%9A%84%E7%BA%A6%E6%9D%9F.jpg" alt=""></p>
<h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><h4 id="单字段主键"><a href="#单字段主键" class="headerlink" title="单字段主键"></a>单字段主键</h4><p>单字段主键指的是由一个字段构成的主键，其基本语法格式如下所示:<br><code>字段名 数据类型 primary key；</code></p>
<pre><code> mysql-&gt;create table example(
      -&gt;id int primary key,
      -&gt;name varchar(20),
      -&gt;grade float);</code></pre><h4 id="多字段主键"><a href="#多字段主键" class="headerlink" title="多字段主键"></a>多字段主键</h4><p>多字段主键指的是多个字段组合而成的主键，其基本的语法格式如下所示:<br><code>primary key（字段名1,字段2名,...,字段名n）；</code></p>
<pre><code>     mysql-&gt;create table example1(
         -&gt;stu_id int,
         -&gt;course_id int,
         -&gt;grade float,
         -&gt;primary key(stu_id,course_id));</code></pre><blockquote>
<p>注意：每个数据表中最多只能有一个主键约束，定义为primary key的字段不能有重复值且不能为null值;</p>
</blockquote>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>由于外键约束涉及多表操作，这里就不进行说明了。</p>
<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p>非空约束值得是字段的值不能为null，在MySQL中，非空约束是通过notnull定义的，其基本语法格式如下：<br><code>字段名 数据类型 not null；</code></p>
<pre><code>    mysql-&gt;create table example2(
         -&gt;id int primary key,
         -&gt;name varchar(20) not null,
         -&gt;grade float);</code></pre><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>唯一约束用于保证数据表中字段的唯一性，即表中字段的值不能重复出现。唯一约束是通过    unique定义的，其基本语法的格式如下所示：<br><code>字段名 数据类型 unique；</code></p>
<pre><code>mysql&gt;create table example3(
    -&gt;id int primary key,
    -&gt;stu_id int unique,
    -&gt;name varchar(20)not null);</code></pre><h3 id="自增约束"><a href="#自增约束" class="headerlink" title="自增约束"></a>自增约束</h3><p>在数据表中，若想为表中插入新的记录自动生成唯一的ID,可以使用auto_increment约束来实现。auto_increment约束的字段可以是任何整数类型。默认情况下，该字段的值是从1开始自增的。使用auto_increment设置表字段值自动增加的基本语法格式如下所示：<br><code>字段名 数据类型 auto_increment；</code></p>
<pre><code>    mysql&gt;create table example5(
        -&gt;id int primary key auto_increment,
        -&gt;stu_id int unique,
        -&gt;grade float);</code></pre><h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><p>默认约束用于非数据表中字段指定默认值，即当在表中插入一条新记录是，如果么哦呦给这个字段赋值，那么，数据库系统会自动给这个字段插入默认值。默认值是通过default关键字定义的，其基本的语法格式如下所示：<br><code>字段名 数据类型 default 默认值；</code></p>
<pre><code>    mysql&gt;create table example4(
        -&gt;id int primary key,
        -&gt;stu_id int unique,
        -&gt;grade float default 0);</code></pre>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>表的约束</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据类型详解</title>
    <url>/2019/12/14/mysql-shu-ju-lei-xing-xiang-jie/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>使用mysql数据库存储数据时，不同的类型决定了不同mysql不同的存储方式不同。为此mysql数据库提供了多种数据类型，其中包括整数类型、浮点数类型、定点数类型、日期和时间类型和二进制类型。下面将对此进行详解。</p>
<h2 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a>1.整数类型</h2><p>在Mysql数据库中，经常需要存储整数数值。根据数值取值范围的不同，Mysql中的整数类型可分为五种，分别是TINYINT、SMALLINT、MEDIUMINT、INT和BIGINT。<br><img src="http://qiniuyun.dajienihao.cn/image/1211/image.png" alt=""><br>从表中可以看出，不同的整数类型占用的字节数和取值范围都不同。需要注意的是，不同整数类型的取值范围是可以根据字节数算出来的。</p>
<h2 id="2-浮点数类型和定点数类型"><a href="#2-浮点数类型和定点数类型" class="headerlink" title="2.浮点数类型和定点数类型"></a>2.浮点数类型和定点数类型</h2><p>在mysql数据库中小数都是使用浮点数和定点数来表示的。浮点数的类型可以分为单精度浮点数类型（FLOAT）和双精度浮点数类型（DOUBLE）。而定点数类型只有DECMIMAL（M，D）<br><img src="http://qiniuyun.dajienihao.cn/image/1214/%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%92%8C%E5%AE%9A%E7%82%B9%E5%9E%8B.jpg241642558434741.png" alt=""></p>
<p>从表中可以看出DECIMAL类型的取值范围与DOUBLE类型的取值范围相同，需要注意的是DECIMAL的有效取值范围是由M和D决定的。其中，M表示的是数据的长度，D表示小数点后的长度。比如将DECIMAL（6，2）的数据3.14159插入数据库中，现实的结果为3.14。</p>
<h2 id="3-日期与时间类型"><a href="#3-日期与时间类型" class="headerlink" title="3.日期与时间类型"></a>3.日期与时间类型</h2><p>为了方便在数据库中存储时间和日期，mysql提供了表示日期和时间的数据类型。分别是YEAR、DATE、TIME、DATETIME和TIMESTAMP。<br><img src="http://qiniuyun.dajienihao.cn/20191121112931554.jpg" alt=""><br>从表中可以看出每种日期和时间类型的取值范围都是不同的。需要注意的是如果插入的数值不合法，系统会自动将对应的零值插入数据库中。</p>
<h2 id="4-字符串和二进制类型"><a href="#4-字符串和二进制类型" class="headerlink" title="4.字符串和二进制类型"></a>4.字符串和二进制类型</h2><p>为了存储字符串、图片和声音等数据，mysql提供了字符串类型和二进制类型。<br><img src="http://qiniuyun.dajienihao.cn/image/1214/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9E%8B.jpg" alt=""><br>表中列举的字符串和二进制类型，不同的数据类型具有不同的特点。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库及表的基本操作</title>
    <url>/2019/12/11/mysql-shu-ju-ku-ji-biao-de-ji-ben-cao-zuo/</url>
    <content><![CDATA[<h2 id="mysql简单操作"><a href="#mysql简单操作" class="headerlink" title="mysql简单操作"></a>mysql简单操作</h2><h3 id="mysql服务的启动与暂停"><a href="#mysql服务的启动与暂停" class="headerlink" title="mysql服务的启动与暂停"></a>mysql服务的启动与暂停</h3><pre><code>net start mysql
net stop mysql</code></pre><h3 id="mysql登录"><a href="#mysql登录" class="headerlink" title="mysql登录"></a>mysql登录</h3><pre><code>-u用户名 -p密码</code></pre><h3 id="创建和查看数据库"><a href="#创建和查看数据库" class="headerlink" title="创建和查看数据库"></a>创建和查看数据库</h3><pre><code>create database 数据库名称
show crate database 数据库名称</code></pre><h3 id="修改数据库编码"><a href="#修改数据库编码" class="headerlink" title="修改数据库编码"></a>修改数据库编码</h3><pre><code>alter database 数据库名称 default character set 编码方式 collate 编码方式_bin</code></pre><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre><code>drop database 数据库名称</code></pre><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code>create table 表名（
字段1，数据类型[完整性约束条件]
字段2，数据类型[完整性约束条件]
.......
）</code></pre><h3 id="查看库中表"><a href="#查看库中表" class="headerlink" title="查看库中表"></a>查看库中表</h3><pre><code>show tables</code></pre><h3 id="查看数据表"><a href="#查看数据表" class="headerlink" title="查看数据表"></a>查看数据表</h3><pre><code>1.show create table 表名（后加\G可以使结果整齐美观）
2.desc 表名</code></pre><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><pre><code>alter table 表名 rename [to] 新表名</code></pre><h3 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h3><pre><code>alter table 表名 change 旧字段名 新字段名 数据类型</code></pre><h3 id="修改字段的数据类型"><a href="#修改字段的数据类型" class="headerlink" title="修改字段的数据类型"></a>修改字段的数据类型</h3><pre><code>alter table 表名 modify 字段名 数据类型</code></pre><h3 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h3><pre><code>alter table 表名 add 新字段名 数据类型[约束条件][first|after 已存在字段名]</code></pre><h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><pre><code>alter table 表名 drop 字段名</code></pre><h3 id="修改字段的排列位置"><a href="#修改字段的排列位置" class="headerlink" title="修改字段的排列位置"></a>修改字段的排列位置</h3><pre><code>alter table 表名 modify 字段名1 数据类型 first|after 字段名2</code></pre><h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><pre><code>drop table 表名   </code></pre>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC设计模式</title>
    <url>/2019/12/08/mvc-she-ji-mo-shi/</url>
    <content><![CDATA[<h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><p><strong>MVC</strong>全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<ul>
<li><p>Model（模型） 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</p>
</li>
<li><p>View（视图） - 视图代表模型包含的数据的可视化。</p>
</li>
<li><p>Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</p>
</li>
</ul>
<p><img src="http://qiniuyun.dajienihao.cn/image/1208/mvc%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h2 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h2><p>毕竟没有什么设计模式是完美的，优点和缺点总是各有千秋。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="1-低耦合"><a href="#1-低耦合" class="headerlink" title="1.低耦合"></a>1.低耦合</h4><p>通过将视图层和业务层分离，允许更改视图层代码而不必重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变，只需要改动MVC的模型层（及控制器）即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。</p>
<p>模型层是自包含的，并且与控制器和视图层相分离，所以很容易改变应用程序的数据层和业务规则。如果想把数据库从 MySQL 移植到 Oracle，或者改变基于 RDBMS 的数据源到 LDAP，只需改变模型层即可。一旦正确的实现了模型层，不管数据来自数据库或是 LDAP服务器，视图层都将会正确的显示它们。由于运用 MVC 的应用程序的三个部件是相互独立，改变其中一个部件并不会影响其它两个，所以依据这种设计思想能构造出良好的松耦合的构件。</p>
<h4 id="2-重用性高"><a href="#2-重用性高" class="headerlink" title="2.重用性高"></a>2.重用性高</h4><p>随着技术的不断进步，当前需要使用越来越多的方式来访问应用程序了。MVC模式允许使用各种不同样式的视图来访问同一个服务端的代码，这得益于多个视图（如WEB（HTTP）浏览器或者无线浏览器（WAP））能共享一个模型。</p>
<p>比如，用户可以通过电脑或通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式（流程）是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面（视图）使用。例如，很多数据可能用 HTML 来表示，但是也有可能用 WAP 来表示，而这些表示的变化所需要的是仅仅是改变视图层的实现方式，而控制层和模型层无需做任何改变。</p>
<p>由于已经将数据和业务规则从表示层分开，所以可以最大化的进行代码重用了。另外，模型层也有状态管理和数据持久性处理的功能，所以，基于会话的购物车和电子商务过程，也能被Flash网站或者无线联网的应用程序所重用。</p>
<h4 id="3-生命周期成本低"><a href="#3-生命周期成本低" class="headerlink" title="3.生命周期成本低"></a>3.生命周期成本低</h4><p>MVC模式使开发和维护用户接口的技术含量降低。</p>
<h4 id="4-部署快"><a href="#4-部署快" class="headerlink" title="4.部署快"></a>4.部署快</h4><p>使用MVC模式进行软件开发，使得软件开发时间得到相当大的缩减，它使后台程序员集中精力于业务逻辑，界面程序员集中精力于表现形式上。</p>
<h4 id="5-可维护性高"><a href="#5-可维护性高" class="headerlink" title="5.可维护性高"></a>5.可维护性高</h4><p>分离视图层和业务逻辑层使得WEB应用更易于维护和修改。</p>
<h4 id="6-有利软件工程化管理"><a href="#6-有利软件工程化管理" class="headerlink" title="6.有利软件工程化管理"></a>6.有利软件工程化管理</h4><p>由于不同的组件（层）各司其职，每一层不同的应用会具有某些相同的特征，这样就有利于通过工程化、工具化的方式管理程序代码。控制器同时还提供了一个好处，就是可以使用控制器来联接不同的模型和视图，来实现用户的需求，这样控制器可以为构造应用程序提供强有力的手段。给定一些可重用的模型和视图，控制器可以根据用户的需求选择模型进行处理，然后选择视图将处理结果显示给用户。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="1-没有明确的定义"><a href="#1-没有明确的定义" class="headerlink" title="1.没有明确的定义"></a>1.没有明确的定义</h4><p>完全理解MVC模式并不是很容易。使用MVC模式需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考软件的架构。同时由于模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难。每个构件在使用之前都需要经过彻底的测试。</p>
<h4 id="2-不适合小、中型应用程序"><a href="#2-不适合小、中型应用程序" class="headerlink" title="2.不适合小、中型应用程序"></a>2.不适合小、中型应用程序</h4><p>花费大量时间将MVC模式应用到规模并不是很大的应用程序通常会得不偿失。</p>
<h4 id="3-增加系统结构和实现的复杂性"><a href="#3-增加系统结构和实现的复杂性" class="headerlink" title="3.增加系统结构和实现的复杂性"></a>3.增加系统结构和实现的复杂性</h4><p>对于简单的界面来说，非要严格遵循MVC模式，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</p>
<p>####4.视图对模型数据的低效率访问 ####<br>依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</p>
]]></content>
      <categories>
        <category>MVC</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse导入普通javaweb项目报错问题</title>
    <url>/2019/11/23/eclipse-dao-ru-pu-tong-javaweb-xiang-mu-bao-cuo-wen-ti/</url>
    <content><![CDATA[<h2 id="Eclipse导入javaweb项目代码报错解决方案"><a href="#Eclipse导入javaweb项目代码报错解决方案" class="headerlink" title="Eclipse导入javaweb项目代码报错解决方案"></a>Eclipse导入javaweb项目代码报错解决方案</h2><p>相信大家在前期学习javaweb的时候导入项目都会碰到一个问题，那就是导入Javaweb项目时代码没有报错但项目图标就是有红叉。</p>
<p>以下是我导入项目发生的错误，我带大家看一下<br><img src="http://qiniuyun.dajienihao.cn/1122%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99.png" alt=""><br>导入项目时会出现这样的错误，jsp页面全部报错！下面我把我如何解决的方法告诉大家：</p>
<h3 id="1-首先，点开你导入项目的项目名，右键选择Build-Path-gt-Configure-Build-Path"><a href="#1-首先，点开你导入项目的项目名，右键选择Build-Path-gt-Configure-Build-Path" class="headerlink" title="1.首先，点开你导入项目的项目名，右键选择Build Path--------&gt;Configure Build Path"></a><strong>1.首先，点开你导入项目的项目名，右键选择<code>Build Path--------&gt;Configure Build Path</code></strong></h3><p><img src="http://qiniuyun.dajienihao.cn/1122lib.png" alt=""></p>
<h4 id="1-选中有红叉的jre点击remove"><a href="#1-选中有红叉的jre点击remove" class="headerlink" title="1.选中有红叉的jre点击remove"></a>1.选中有红叉的jre点击remove</h4><h4 id="2-然后点击Add-Library"><a href="#2-然后点击Add-Library" class="headerlink" title="2.然后点击Add Library"></a>2.然后点击Add Library</h4><h4 id="3-选择JRE-System-Library-点击next"><a href="#3-选择JRE-System-Library-点击next" class="headerlink" title="3.选择JRE System Library 点击next"></a>3.选择JRE System Library 点击next</h4><p><img src="http://qiniuyun.dajienihao.cn/1122addlib.png" alt=""></p>
<h4 id="4-点击Installed选择你的你本机的jre在点击Apply即可"><a href="#4-点击Installed选择你的你本机的jre在点击Apply即可" class="headerlink" title="4.点击Installed选择你的你本机的jre在点击Apply即可"></a>4.点击Installed选择你的你本机的jre在点击Apply即可</h4><p><img src="http://qiniuyun.dajienihao.cn/addjre.png" alt=""></p>
<h3 id="2-在再左边找到Project-Facets"><a href="#2-在再左边找到Project-Facets" class="headerlink" title="2.在再左边找到Project Facets"></a><strong>2.在再左边找到Project Facets</strong></h3><h4 id="1-点击java栏右边下拉框-选择你的版本（我这里是1-8版本所以我选择1-8版本）"><a href="#1-点击java栏右边下拉框-选择你的版本（我这里是1-8版本所以我选择1-8版本）" class="headerlink" title="1.点击java栏右边下拉框 选择你的版本（我这里是1.8版本所以我选择1.8版本）"></a>1.点击java栏右边下拉框 选择你的版本（我这里是1.8版本所以我选择1.8版本）</h4><p><img src="http://qiniuyun.dajienihao.cn/add1.8.png" alt=""></p>
<h4 id="2-再点击Run-Times选择你的Tomcat版本-如果没有的的话new一个然后Apply就发现-报错已经全部消失了"><a href="#2-再点击Run-Times选择你的Tomcat版本-如果没有的的话new一个然后Apply就发现-报错已经全部消失了" class="headerlink" title="2.再点击Run Times选择你的Tomcat版本 如果没有的的话new一个然后Apply就发现 报错已经全部消失了"></a>2.再点击Run Times选择你的Tomcat版本 如果没有的的话new一个然后Apply就发现 报错已经全部消失了</h4><p><img src="http://qiniuyun.dajienihao.cn/finsh.png" alt=""></p>
<h3 id="3-到这里就已经成功了嗷，如果还有问题的话可以私聊我"><a href="#3-到这里就已经成功了嗷，如果还有问题的话可以私聊我" class="headerlink" title="3.到这里就已经成功了嗷，如果还有问题的话可以私聊我"></a>3.到这里就已经成功了嗷，如果还有问题的话可以私聊我</h3>]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>后端</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射基础</title>
    <url>/2019/10/31/java-ji-chu-fan-she/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Java反射(<code>Reflection</code>)机制就是在运行状态中，对于任意一个类，都能够知道这个类的属性和方法。对于任意一个对象能够调用它的任意一个属性和方法。这种动态获取的信息和动态调用对象的方法的功能称为Java语言的反射机制。Java程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p>反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。反射机制就是通过<code>java.lang.Class</code>类来实现的，在<code>Java</code>中，<code>Object</code>类是所有类的根类，而<code>Class</code>类就是描述Java类的类。</p>
<blockquote>
<p>注：因为<code>Class</code>类也是类，所以<code>Object</code>也包括<code>Class</code>类。</p>
</blockquote>
<h3 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2. 主要功能"></a>2. 主要功能</h3><p>Java反射框架主要提供以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用<code>private</code>方法）；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>修改构造函数、方法、属性的可见性。</li>
</ul>
<h3 id="3-主要用途"><a href="#3-主要用途" class="headerlink" title="3. 主要用途"></a>3. 主要用途</h3><p><strong>反射最重要的用途就是开发各种通用框架</strong>。很多框架（比如<code>Spring</code>）都是配置化的（比如通过XML文件配置<code>JavaBean</code>,<code>Action</code>之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。</p>
<h2 id="二、反射的作用"><a href="#二、反射的作用" class="headerlink" title="二、反射的作用"></a>二、反射的作用</h2><h3 id="1-获取class对象"><a href="#1-获取class对象" class="headerlink" title="1. 获取class对象"></a>1. 获取class对象</h3><p>反射的各种功能都需要通过<code>Class</code>对象来实现，因此，需要知道如何获取<code>Class</code>对象，主要有以下几种方式。</p>
<h4 id="使用-Class-forName-的静态方法"><a href="#使用-Class-forName-的静态方法" class="headerlink" title="使用 Class.forName() 的静态方法"></a>使用 Class.forName() 的静态方法</h4><p><code>Class.forName(String className)</code>方法可以通过类或接口的名称（一个字符串或完全限定名）来获取对应的<code>Class</code>对象。</p>
<pre class=" language-java"><code class="language-java">    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.blinkfox.Zealot"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="直接获取某个类的class-最安全-性能最好"><a href="#直接获取某个类的class-最安全-性能最好" class="headerlink" title="直接获取某个类的class(最安全/性能最好)"></a>直接获取某个类的class(最安全/性能最好)</h4><pre class=" language-java"><code class="language-java">    Class<span class="token operator">&lt;</span>String<span class="token operator">></span> cls <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span></code></pre>
<h4 id="调用某个对象的-getClass-方法"><a href="#调用某个对象的-getClass-方法" class="headerlink" title="调用某个对象的 getClass() 方法"></a>调用某个对象的 getClass() 方法</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="2-判断是否为某个类的实例"><a href="#2-判断是否为某个类的实例" class="headerlink" title="2. 判断是否为某个类的实例"></a>2. 判断是否为某个类的实例</h3><p>一般地，我们用<code>instanceo</code>f关键字来判断是否为某个类的实例。同时我们也可以借助反射中<code>Class</code>对象的<code>isInstance()</code>方法来判断是否为某个类的实例，它是一个<code>Native</code>方法：</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="3-创建实例"><a href="#3-创建实例" class="headerlink" title="3. 创建实例"></a>3. 创建实例</h3><p>通过反射来生成对象主要有两种方式。</p>
<h4 id="使用Class对象的newInstance-方法"><a href="#使用Class对象的newInstance-方法" class="headerlink" title="使用Class对象的newInstance()方法"></a>使用Class对象的newInstance()方法</h4><pre class=" language-java"><code class="language-java">    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    Object str <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance-方法"><a href="#通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance-方法" class="headerlink" title="通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法"></a>通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法</h4><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 获取String所对应的Class对象</span>
    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 获取String类带一个String参数的构造器</span>
    Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 根据构造器创建实例</span>
    Object obj <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"23333"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>注：这种方法可以用指定的构造器构造类的实例。</p>
</blockquote>
<h3 id="4-获取方法"><a href="#4-获取方法" class="headerlink" title="4. 获取方法"></a>4. 获取方法</h3><p>获取某个<code>Class</code>对象的方法集合，主要有以下几个方法：</p>
<ul>
<li><code>getDeclaredMethods</code>()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</li>
</ul>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException</code></pre>
<ul>
<li><code>getMethods</code>()方法返回某个类的所有公用（<code>public</code>）方法，包括其继承类的公用方法。</li>
</ul>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException
</code></pre>
<ul>
<li><code>getMethod</code>()方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应<code>Class</code>的对象。</li>
</ul>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Method <span class="token function">getMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span></code></pre>
<p>代码示例：</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span>
    <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>
    InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>
    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> MethodClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    Object object <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Method<span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Method<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredMethods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//获取MethodClass类的add方法</span>
    Method method <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//getMethods()方法获取的所有方法</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getMethods获取的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//getDeclaredMethods()方法获取的所有方法</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getDeclaredMethods获取的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span> declaredMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">MethodClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fuck <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">}</span></code></pre>
<blockquote>
<p>注：通过<code>getMethods()</code>获取的方法可以获取到父类的方法,比如<code>java.lang.Object</code>下定义的各个方法。</p>
</blockquote>
<h3 id="5-获取构造方法"><a href="#5-获取构造方法" class="headerlink" title="5. 获取构造方法"></a>5. 获取构造方法</h3><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过<code>Class</code>类的<code>getConstructor</code>方法得到<code>Constructor</code>类的一个实例，而<code>Constructor</code>类有一个<code>newInstance</code>方法可以创建一个对象实例:</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> T <span class="token function">newInstance</span><span class="token punctuation">(</span>Object <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initargs<span class="token punctuation">)</span></code></pre>
<h3 id="6-获取类的成员变量信息"><a href="#6-获取类的成员变量信息" class="headerlink" title="6. 获取类的成员变量信息"></a>6. 获取类的成员变量信息</h3><p>获取的方法同<code>Method</code>相似，主要是这几个方法，在此不再赘述：</p>
<ul>
<li><code>Field getField(String name)</code>: 访问公有的成员变量。</li>
</ul>
<ul>
<li><code>Field[] getDeclaredFields()</code>：所有已声明的成员变量。但不能得到其父类的成员变量。</li>
</ul>
<ul>
<li><p><code>Field[] getFields()</code>和<code>Field[] getDeclaredFields()</code>用法同上。</p>
<h3 id="7-调用方法"><a href="#7-调用方法" class="headerlink" title="7. 调用方法"></a>7. 调用方法</h3><p>当我们从类中获取了一个方法后，我们就可以用<code>invoke()</code>方法来调用这个方法。<code>invoke</code>方法的原型为:</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span>
   InvocationTargetException</code></pre>
<p>代码示例：</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>
  InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>
  Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> klass <span class="token operator">=</span> MethodClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//创建 MethodClass 的实例</span>
  Object obj <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//获取 MethodClass 类的add方法</span>
  Method method <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//调用 method 对应的方法 => add(1,4)</span>
  Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">class</span> <span class="token class-name">MethodClass</span> <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fuck <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token punctuation">}</span></code></pre>
<h3 id="8-利用反射创建数组"><a href="#8-利用反射创建数组" class="headerlink" title="8. 利用反射创建数组"></a>8. 利用反射创建数组</h3><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个<code>Object Reference</code>。下面我们看一看利用反射创建数组的例子：</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 使用`java.lang.reflect.Array`反射创建长度为25的字符串数组.</span>
  Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Object array <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 往数组里添加内容</span>
  Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Go"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Scala"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"Clojure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 获取某一项的内容</span>
  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
<h2 id="三、使用反射获取信息"><a href="#三、使用反射获取信息" class="headerlink" title="三、使用反射获取信息"></a>三、使用反射获取信息</h2><p><code>Class</code>类提供了大量的实例方法来获取该<code>Class</code>对象所对应的详细信息，<code>Class</code>类大致包含如下方法，其中每个方法都包含多个重载版本，因此我们只是做简单的介绍，详细请参考JDK文档。</p>
</li>
</ul>
<h3 id="1-获取类内信息"><a href="#1-获取类内信息" class="headerlink" title="1. 获取类内信息"></a>1. 获取类内信息</h3><ul>
<li>构造器: <code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></li>
<li>包含的方法: <code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></li>
<li>包含的属性: <code>Field getField(String name)</code></li>
<li>内部类: <code>Class&lt;?&gt;[] getDeclaredClasses()</code></li>
<li>外部类: <code>Class&lt;?&gt; getDeclaringClass()</code></li>
<li>所实现的接口: <code>Class&lt;?&gt;[] getInterfaces()</code></li>
<li>修饰符: <code>int getModifiers()</code></li>
<li>所在包: <code>Package getPackage()</code></li>
<li>类名: <code>String getName()</code></li>
<li>简称: <code>String getSimpleName()</code></li>
</ul>
<h3 id="2-判断类本身信息的方法"><a href="#2-判断类本身信息的方法" class="headerlink" title="2. 判断类本身信息的方法"></a>2. 判断类本身信息的方法</h3><ul>
<li>是否注解类型: <code>boolean isAnnotation()</code></li>
<li>是否使用了该<code>Annotation</code>修饰: <code>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></li>
<li>是否匿名类: <code>boolean isAnonymousClass()</code></li>
<li>是否数组: <code>boolean isArray()</code></li>
<li>是否枚举: <code>boolean isEnum()</code></li>
<li>是否原始类型: <code>boolean isPrimitive()</code></li>
<li>是否接口: <code>boolean isInterface()</code></li>
<li>obj是否是该Class的实例: <code>boolean isInstance(Object obj)</code></li>
</ul>
<h3 id="3-使用反射获取泛型信息"><a href="#3-使用反射获取泛型信息" class="headerlink" title="3. 使用反射获取泛型信息"></a>3. 使用反射获取泛型信息</h3><p>为了通过反射操作泛型以迎合实际开发的需要, <code>Java</code>新增了<code>java.lang.reflect.ParameterizedType、java.lang.reflect.GenericArrayType、java.lang.reflect.TypeVariable、java.lang.reflect.WildcardType</code>几种类型来代表不能归一到<code>Class</code>类型但是又和原始类型同样重要的类型。</p>
<p>-<code>ParameterizedType</code>: 一种参数化类型, 比如<code>Collection</code></p>
<ul>
<li><code>GenericArrayType</code>: 一种元素类型是参数化类型或者类型变量的数组类型</li>
<li><code>TypeVariable</code>: 各种类型变量的公共接口</li>
<li><code>WildcardType</code>: 一种通配符类型表达式, 如<code>?、? extends Number、? super Integer</code></li>
</ul>
<p>代码示例：</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> objectMap<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> User<span class="token operator">></span> map<span class="token punctuation">,</span> String string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>User<span class="token punctuation">,</span> Bean<span class="token operator">></span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 测试属性类型
     *
     * @throws NoSuchFieldException
     */</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFieldType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException <span class="token punctuation">{</span>
    Field field <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"objectMap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Type gType <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getGenericType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 打印type与generic type的区别</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>gType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ParameterizedType pType <span class="token operator">=</span> <span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> gType<span class="token punctuation">;</span>
    Type<span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> pType<span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> types<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 测试参数类型
     *
     * @throws NoSuchMethodException
     */</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testParamType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>
    Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Type<span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> parameterTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"type -> "</span> <span class="token operator">+</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 测试返回值类型
     *
     * @throws NoSuchMethodException
     */</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>
    Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Type returnType <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"return type -> "</span> <span class="token operator">+</span> returnType<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>returnType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> returnType<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
]]></content>
      <categories>
        <category>反射</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
</search>
