<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql表的约束</title>
    <url>/2019/12/29/an-zhuo-zi-ding-yi-view-wu-zi-qi-xiang-mu-xiang-xi/</url>
    <content><![CDATA[<p>当初学编程的，都想做一个游戏，俄罗斯方块？贪吃蛇？不不不，今天我所讲的是五子棋双人对战，对比那些来说，应该算比较简单的了。<br>相信很多人都有看过，不过视频中，我发现有些代码是不需要的，而且还存在一些bug，针对视频所存在的bug我都做了调整，经测试，目前无bug。<br>创建一个类，然后继承View，需要实现构造方法，我们选择两个参数的构造方法就行了<br>下面贴出代码：</p>
<pre><code>public panel(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();//初始化方法
    }</code></pre><p>所需定义的内容：</p>
<pre><code>private int mPanelWidth;
private float mLineHeight;//棋盘行距
private int MAX_LINE = 10;//棋盘行数
private Paint mPaint = new Paint();//绘制对象
private Bitmap mWhitePiece;//白色棋子
private Bitmap mBlackPiece;//黑色棋子
private boolean mIsWhite = true;//白棋先手，当前轮到白棋出子
private List&lt;Point&gt; mWhiteArray = new ArrayList&lt;&gt;();//放白色棋子落子的坐标
private List&lt;Point&gt; mBlackArray = new ArrayList&lt;&gt;();//放黑色棋子落子的坐标
private float ratioPieceOfLineHeight = 3 * 1.0f / 4;//棋子占据的比例
private boolean mIsGameOver;//判断游戏结束
private boolean mIsWhiteWinner;//true白子胜利，false黑子胜利
private int MAX_COUNT_IN_LINE = 5;//五子棋数</code></pre><p>  对画笔的初始化：</p>
<pre><code> private void init() {//初始化方法
        mPaint.setColor(Color.rgb(0, 0, 0));//设置颜色
        mPaint.setAntiAlias(true);//抗锯齿
        mPaint.setDither(true);//设置防抖动
        mPaint.setStyle(Paint.Style.STROKE);//绘制棋盘线条，画笔为描边样式
        mWhitePiece = BitmapFactory.decodeResource(getResources(), R.drawable.stone_w2);//设置白色棋子图片
        mBlackPiece = BitmapFactory.decodeResource(getResources(), R.drawable.stone_b1);//设置黑色棋子图片
    }</code></pre><p> 对于自定义view有一定基础的小伙伴都知道，自定义一般都要实现2个方法，1：onSizeChanged（视图大小的改变）；2：onMeasure（告诉父view，子视图占用多大的空间）<br>下面上代码，我都有详细注解，就不一个一个解释了：<br>onMeasure：</p>
<pre><code>    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {//设置棋盘大小
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);//获取宽度
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);//根据测量值提取模式
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);//获取高度
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);//根据测量值提取模式
        int width = Math.min(widthSize, heightSize);//取最小值获取设置正方形棋盘
        if (widthMode == MeasureSpec.UNSPECIFIED)//当模式为未指定模式时就为棋盘长宽就为高度
            width = heightSize;
        else if (heightMode == MeasureSpec.UNSPECIFIED)//当模式为未指定模式时就为棋盘长宽就为宽度
            width = widthSize;
        setMeasuredDimension(width, width);//取宽高的最小值绘制棋盘
    }</code></pre><p> onSizeChanged：</p>
<pre><code> protected void onSizeChanged(int w, int h, int oldw, int oldh) {//当宽高发生改变进行回调
        super.onSizeChanged(w, h, oldw, oldh);
        mPanelWidth = w;
        mLineHeight = mPanelWidth * 1.0f / MAX_LINE;//棋盘行距
        int pieceWidth = (int) (mLineHeight * ratioPieceOfLineHeight);//棋子比列
        mWhitePiece = Bitmap.createScaledBitmap(mWhitePiece, pieceWidth, pieceWidth, false);//设置棋子大小
        mBlackPiece = Bitmap.createScaledBitmap(mBlackPiece, pieceWidth, pieceWidth, false);//设置棋子大小
    }</code></pre><p> 好了，下面我们进图画图操作，需要的操作是，先画棋盘，在画棋子，然后判断游戏结束。</p>
<pre><code>  protected void onDraw(Canvas canvas) {//绘制方法
        super.onDraw(canvas);
        drawBoard(canvas);//绘制棋盘
        drawPiece(canvas);//绘制棋子
        checkGameOver();//检查游戏是否结束
    }</code></pre><p> 绘制棋盘：</p>
<pre><code>  private void drawBoard(Canvas canvas) {//绘制棋盘方法
        int w = mPanelWidth;//棋盘宽度
        float lineHeight = mLineHeight;//棋盘行距
        for (int i = 0; i &lt; MAX_LINE; i++) {
            int startX = (int) (lineHeight / 2);//起点坐标
            int endX = (int) (w - lineHeight / 2);//终点坐标
            int y = (int) ((0.5 + i) * lineHeight);//y轴起点坐标
            canvas.drawLine(startX, y, endX, y, mPaint);//绘制x轴线条
            canvas.drawLine(y, startX, y, endX, mPaint);//绘制y轴线条
        }
    }</code></pre><p>绘制棋子：</p>
<pre><code>private void drawPiece(Canvas canvas) {//绘制棋子方法
        for (int i = 0; i &lt; mWhiteArray.size(); i++) {
            Point whitePoint = mWhiteArray.get(i);//拿到棋子
            canvas.drawBitmap(mWhitePiece,
                    (whitePoint.x + (1 - ratioPieceOfLineHeight) / 2) * mLineHeight,
                    (whitePoint.y + (1 - ratioPieceOfLineHeight) / 2) * mLineHeight, null);//棋子坐标计算
        }
        for (int i = 0; i &lt; mBlackArray.size(); i++) {
            Point blackPoint = mBlackArray.get(i);//拿到棋子
            canvas.drawBitmap(mBlackPiece,
                    (blackPoint.x + (1 - ratioPieceOfLineHeight) / 2) * mLineHeight,
                    (blackPoint.y + (1 - ratioPieceOfLineHeight) / 2) * mLineHeight, null);//棋子坐标计算
        }
    }</code></pre><p>判断游戏是否结束:</p>
<pre><code>private void checkGameOver() {//判断游戏是否结束及和棋
        boolean whiteWin = checkFiveInLine(mWhiteArray);//白子成功五子连珠
        boolean blackWin = checkFiveInLine(mBlackArray);//黑子成功五子连珠
        int max = MAX_LINE * MAX_LINE;//最大落子数的和
        if (whiteWin || blackWin) {//有人胜利
            mIsGameOver = true;//游戏结束
            mIsWhiteWinner = whiteWin;
            String text = mIsWhiteWinner ? &quot;白棋胜利&quot; : &quot;黑棋胜利&quot;;//白子赢了提示白棋胜利，否者黑棋胜利
            if (mIsGameOver) {
                AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
                builder.setIcon(R.drawable.dy);
                builder.setTitle(&quot;游戏结束，&quot; + text);
                builder.setMessage(&quot;请选项下面选项！！！！&quot;);
                builder.setNegativeButton(&quot;退出游戏&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        System.exit(0);
                    }
                });
                builder.setNeutralButton(&quot;查看棋盘！&quot;, new DialogInterface.OnClickListener() {

                    public void onClick(DialogInterface dialogInterface, int i) {
                        dialogInterface.dismiss();
                    }
                });
                builder.setPositiveButton(&quot;再来一局&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        reStart();
                    }
                });
                builder.setCancelable(false);
                builder.show();
            }
        } else if ((mBlackArray.size() + mWhiteArray.size()) == max) {//当白棋子数和黑棋字数相加等于最大数时无人胜利，双方和棋
            AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
            builder.setIcon(R.drawable.dy);
            builder.setTitle(&quot;棋逢对手,将遇良才！&quot;);
            builder.setMessage(&quot;二位和棋，是否再战一句！！！&quot;);
            builder.setNegativeButton(&quot;退出游戏&quot;, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    System.exit(0);
                }
            });
            builder.setNeutralButton(&quot;查看棋盘！&quot;, new DialogInterface.OnClickListener() {

                public void onClick(DialogInterface dialogInterface, int i) {
                    dialogInterface.dismiss();
                }
            });
            builder.setPositiveButton(&quot;再来一局&quot;, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    reStart();
                }
            });
            builder.setCancelable(false);
            builder.show();
        }
    }</code></pre><p>游戏结束的判断的依据：</p>
<pre><code>private boolean checkFiveInLine(List&lt;Point&gt; points) {//判断是否五子连珠
        for (Point p : points) {
            int x = p.x;
            int y = p.y;
            boolean win = checkHorizontal(x, y, points);//判断xy位置的棋子是否有左右相邻的五个一致
            if (win)
                return true;
            win = checkVertiacal(x, y, points);//判断xy位置的棋子是否有上下相邻的五个一致
            if (win)
                return true;
            win = checkLeftDiagonal(x, y, points);//判断xy位置的棋子是否有左斜相邻的五个一致
            if (win)
                return true;
            win = checkRightDiagonal(x, y, points);//判断xy位置的棋子是否有右斜相邻的五个一致
            if (win)
                return true;
        }
        return false;
    }</code></pre><p>判断是否有横向五子连珠：</p>
<pre><code>private boolean checkHorizontal(int x, int y, List&lt;Point&gt; points) {//判断x，y位置的棋子是否有横向相邻的五个一致
        int count = 1;//当前子
        for (int i = 1; i &lt; MAX_COUNT_IN_LINE; i++) {//从当前子往左数最大4个，如果有相同子count加1
            if (points.contains(new Point(x - i, y))) {
                count++;
            } else {
                break;
            }
        }
        if (count == MAX_COUNT_IN_LINE)//如果count为5表示成功连珠
            return true;


        for (int i = 1; i &lt; MAX_COUNT_IN_LINE; i++) {//从当前子往右数最大4个，如果有相同子count加1
            if (points.contains(new Point(x + i, y))) {
                count++;
            } else {
                break;
            }
        }
        if (count == MAX_COUNT_IN_LINE)//如果count为5表示成功连珠
            return true;
        return false;
    }</code></pre><p>其他方向的代码和上面一样只是循环中x，y的值改一下，就不放具体代码了，具体提示一下竖向判断的(x,y-1),(x,y+1）左斜是(x - i, y + i),(x + i, y - i) 右斜是(x - i, y - i),(x + i, y + i)<br>重新开始游戏:</p>
<pre><code>public void reStart() {//重新开始游戏
        mWhiteArray.clear();
        mBlackArray.clear();
        mIsGameOver = false;
        mIsWhiteWinner = false;
        mIsWhite=true;
        invalidate();
    }</code></pre><p>悔棋：</p>
<pre><code>public void withDraw() {//悔棋
        if (mIsGameOver) {
            Toast.makeText(getContext(), &quot;游戏已经结束，不能悔棋&quot;, Toast.LENGTH_LONG).show();
            return;
        }
        if (mBlackArray.size() &gt; 0 || mWhiteArray.size() &gt; 0) {
            if (mIsWhite) {
                mBlackArray.remove(mBlackArray.size() - 1);
                mIsWhite = !mIsWhite;
            } else {
                mWhiteArray.remove(mWhiteArray.size() - 1);
                mIsWhite = !mIsWhite;
            }
            invalidate();
        }
    }</code></pre><p>这里我没有考虑到禁手的问题，感觉如果考虑到禁手的话，算法比较复杂，人机对战。这里呢此类的代码就完成了<br>下面将布局代码发出来</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;
    android:background=&quot;@drawable/bg&quot;&gt;
    &lt;TextView
        android:id=&quot;@+id/textview&quot;
        android:textColor=&quot;#000000&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:textSize=&quot;30dp&quot;
        android:layout_centerHorizontal=&quot;true&quot;
        android:layout_above=&quot;@id/wuziqi&quot;
        /&gt;
    &lt;com.example.myapplication.panel
        android:id=&quot;@+id/wuziqi&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_centerInParent=&quot;true&quot; /&gt;
    &lt;LinearLayout
        android:layout_below=&quot;@id/wuziqi&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_marginLeft=&quot;60dp&quot;
        android:layout_marginRight=&quot;60dp&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;Button
            android:id=&quot;@+id/restart&quot;
            android:text=&quot;重新开始&quot;
            android:onClick=&quot;reStart&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;/&gt;
        &lt;TextView
            android:layout_weight=&quot;1&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;&quot;/&gt;
        &lt;Button
            android:id=&quot;@+id/withdraw&quot;
            android:text=&quot;悔棋&quot;
            android:onClick=&quot;withdraw&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;/&gt;
    &lt;/LinearLayout&gt;
&lt;/RelativeLayout&gt;</code></pre><p>mainactivity.java文件的代码也发出来</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    panel panel;
    TextView textView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        panel=findViewById(R.id.wuziqi);
    }

    public void reStart(View view) {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setIcon(R.drawable.dy);
        builder.setTitle(&quot;重新开始&quot;);
        builder.setMessage(&quot;重新开始游戏需要双方棋手同意请选择！！！&quot;);
        builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

            }
        });
        builder.setPositiveButton(&quot;重新开始&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                panel.reStart();
            }
        });
        builder.setCancelable(false);
        builder.show();
    }

    public void withdraw(View view) {

        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setIcon(R.drawable.dy);
        builder.setTitle(&quot;悔棋&quot;);
        builder.setMessage(&quot;悔棋需要双方棋手同意请选择！！！&quot;);
        builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

            }
        });
        builder.setPositiveButton(&quot;确定悔棋&quot;, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                panel.withDraw();
            }
        });
        builder.setCancelable(false);
        builder.show();
    }
}</code></pre><p>好了到这里安卓五子棋的项目就完成了，自定义view的难度在于给viwe的大小及测量，完成这些的话其实自定义view并没有这么难。</p>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>自定义view</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的索引</title>
    <url>/2019/12/21/mysql-de-suo-yin/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>在数据库操作中，经常需要查询特定的数据，例如，当执行<code>select * from student where id=10000</code>语句时，MySQL数据库必须从第一条记录开始遍历，直到找出id为10000的数据，这样的效率显然非常低。为此，MySQL允许建立索引来加快数据表的查询和排序。</p>
<h2 id="1-索引的概念"><a href="#1-索引的概念" class="headerlink" title="1.索引的概念"></a>1.索引的概念</h2><p>数据库的索引好比新华字典的音序表，它是对数据库表中一列或多列的值进行排序后的一种结构，其作用就是提高表中数据的查询进度。MySQL的索引分为很多种，具体如下：</p>
<h3 id="1-1普通索引"><a href="#1-1普通索引" class="headerlink" title="1.1普通索引"></a>1.1普通索引</h3><p>普通索引是由<code>key或index</code>定义的索引，他是mysql中的基本索引类型，可以创建在任何数据类型中，其值是否唯一和非空由字段本身的约束条件决定。例如，在grade表的stu_id字段上建立一个普通索引，查询记录时，就可以根据该索引进行查询了。</p>
<h3 id="1-2唯一性索引"><a href="#1-2唯一性索引" class="headerlink" title="1.2唯一性索引"></a>1.2唯一性索引</h3><p>唯一性索引是由<code>UNIQUE</code>定义的索引，该索引所在的字段必须是唯一的。例如，在grade表的id字段建立唯一性索引，那么，id字段的值就必须是唯一的。</p>
<h3 id="1-3全文索引"><a href="#1-3全文索引" class="headerlink" title="1.3全文索引"></a>1.3全文索引</h3><p>全文索引是由<code>FULLTEXT</code>定义的索引，他只能创建在<code>char、varchar或text</code>类型上的字段上，而且只有<code>MYISAM</code>存储引擎支持全文索引。</p>
<h3 id="1-4单列索引"><a href="#1-4单列索引" class="headerlink" title="1.4单列索引"></a>1.4单列索引</h3><p>单列索引指得是在表中单个字段上创建索引，它可以是普通索引、唯一索引或全文索引，只要保证该索引对应表中的一个字段即可。</p>
<h3 id="1-5空间索引"><a href="#1-5空间索引" class="headerlink" title="1.5空间索引"></a>1.5空间索引</h3><p>空间索引是由<code>SPATIAL</code>定义的索引，他只能创建在空间数据类型的字段上，MySQL的空间数据类型有四种，分别是<code>GEOMETRY、POINT、LINESTRING和POLYGON</code>。需要注意的是，创建空间索引的字段，必须将其声明为<code>NOT NULL</code>，并且空间索引只能在<code>MYISAM</code>的表创建。</p>
<blockquote>
<p>需要注意的是，虽然索引可以提高数据的查询速度，但索引会占据一定的磁盘空间，并且在创建和维护索引时，其消耗的时间是随着数据量的增加而增加的。因此使用索引时，应该综合考虑索引的优点和缺点。</p>
</blockquote>
<h2 id="2-创建索引"><a href="#2-创建索引" class="headerlink" title="2.创建索引"></a>2.创建索引</h2><p>要想使用索引提高数据表的查询速度，首先要创建一个索引。创建索引的方法有三种，具体如下。</p>
<h3 id="2-1创建表的时候创建索引"><a href="#2-1创建表的时候创建索引" class="headerlink" title="2.1创建表的时候创建索引"></a>2.1创建表的时候创建索引</h3><p>创建表的时候可以直接创建索引，这中方式最简单、方便，其基本的语法格式如下所示：</p>
<pre><code>create table 表名(字段名 数据类型 [完整约束条件]，
                  字段名 数据类型 [完整约束条件]，
                  ...
                      字段名 数据类型 
                      [UNIQUE|FULLTEXT|SPATIAL] INDEX｜KEY 
                          [别名](字段名1 [(长度)] [ASC]|[DESC])，
）；</code></pre><p>关于上述语法的相关解释具体如下。</p>
<ol>
<li>UNIQUE：可选参数，表示唯一索引。</li>
<li>FULLTEXT：可选参数，表示全文索引。</li>
<li>SPATIAL：可选参数，表示空间索引。</li>
<li>INDEX和KEY：用来表示字段的索引，二选一即可。</li>
<li>别名：可选参数，表示创建的索引名称。</li>
<li>字段名1：指定索引对应字段的名称。</li>
<li>长度：可选参数，用于表示索引的长度。</li>
<li>ASC和DESC：可选参数，其中ASC表示升序排列，DESC表示降序排列。</li>
</ol>
<p>为了帮助读者更好地了解如何在创建表的时候创建索引，接下来，通过具体的案例，分别对MySQL的六种索引类型进行详解，具体如下：</p>
<h4 id="2-1-1-创建普通索引"><a href="#2-1-1-创建普通索引" class="headerlink" title="2.1.1 创建普通索引"></a>2.1.1 创建普通索引</h4><pre><code>create table t1(id int，
                name varchar(20),
                score float,
                INDEX (name)
);</code></pre><h4 id="2-1-2-创建唯一性索引"><a href="#2-1-2-创建唯一性索引" class="headerlink" title="2.1.2 创建唯一性索引"></a>2.1.2 创建唯一性索引</h4><pre><code>create table t2(id int not null,
                name varchar(20) not null,
                score float,
                unique index unique_id(id Asc)
);</code></pre><h4 id="2-1-3-创建全文索引"><a href="#2-1-3-创建全文索引" class="headerlink" title="2.1.3 创建全文索引"></a>2.1.3 创建全文索引</h4><pre><code>create table t3(id int not null,
                name varchar(20) not null,
                score float,
                fulltext index fulltext_name(name)
)engine=myisam;</code></pre><h4 id="2-1-4-创建单列索引"><a href="#2-1-4-创建单列索引" class="headerlink" title="2.1.4 创建单列索引"></a>2.1.4 创建单列索引</h4><pre><code>create table t4(id int not null,
                name varchar(20) not null,
                score float,
                index single_name(name(20))
);</code></pre><h4 id="2-1-5-创建多列索引"><a href="#2-1-5-创建多列索引" class="headerlink" title="2.1.5 创建多列索引"></a>2.1.5 创建多列索引</h4><pre><code>create table t5(id int not null,
                name varchar(20) not null,
                score float,
                index multi(name(20),id)
);</code></pre><h4 id="2-1-6-创建空间索引"><a href="#2-1-6-创建空间索引" class="headerlink" title="2.1.6 创建空间索引"></a>2.1.6 创建空间索引</h4><pre><code>create table t6(id int,
                space GEOMETRY not null,
                SPATIAL index sp(space）
)engine=myisam；</code></pre><h3 id="2-2-创建使用create-index语句在已存在的表上创建索引"><a href="#2-2-创建使用create-index语句在已存在的表上创建索引" class="headerlink" title="2.2 创建使用create index语句在已存在的表上创建索引"></a>2.2 创建使用create index语句在已存在的表上创建索引</h3><p>若想在一个已经存在的表上创建索引，可以使用<code>create index语句，create index</code>语句创建索引的具体语法格式如下所示：</p>
<pre><code>create [UNIQUE|FULLTEXT|SPATIAL] index 索引名
on 表名 （字段名 [(长度)] [ASC|DESC]);</code></pre><p>在上述语法中<code>UNIUE、FULLTEXT和SPATIAL</code>都是可选参数，分别用于表示唯一性索引、全文索引和空间索引；index用于指明字段为索引。<br>为了便于学习如何使用<code>create index</code>语句在已经存在的表创建索引，接下来创建一个book表，该表中没有任何的索引，创建book表的sql语句如下所示：</p>
<pre><code>create table book(
                bookid int not null,
                bookname varchar(255) not null,
                authors varchar(255) not null,
                info varchar(255) null,
                comment varchar(255) null,
                publicyear year not null
);</code></pre><h4 id="2-2-1-创建普通索引"><a href="#2-2-1-创建普通索引" class="headerlink" title="2.2.1 创建普通索引"></a>2.2.1 创建普通索引</h4><p><code>create index index_id on book (bookid);</code></p>
<h4 id="2-2-2-创建唯一性索引"><a href="#2-2-2-创建唯一性索引" class="headerlink" title="2.2.2 创建唯一性索引"></a>2.2.2 创建唯一性索引</h4><p><code>create unique index uniqueidx on book (bookid);</code></p>
<h4 id="2-2-3-创建单列索引"><a href="#2-2-3-创建单列索引" class="headerlink" title="2.2.3 创建单列索引"></a>2.2.3 创建单列索引</h4><p><code>create index singleidx on book(comment);</code></p>
<h4 id="2-2-4-创建多列索引"><a href="#2-2-4-创建多列索引" class="headerlink" title="2.2.4 创建多列索引"></a>2.2.4 创建多列索引</h4><p><code>create index mulitidx on book(authors(20),info(20));</code></p>
<h4 id="2-2-5-创建全文索引"><a href="#2-2-5-创建全文索引" class="headerlink" title="2.2.5 创建全文索引"></a>2.2.5 创建全文索引</h4><p><code>create fulltext index fulltextidx on book(info);</code></p>
<h4 id="2-2-6-创建空间索引"><a href="#2-2-6-创建空间索引" class="headerlink" title="2.2.6 创建空间索引"></a>2.2.6 创建空间索引</h4><p><code>create SPATIAL index spatidx on t7(g);</code></p>
<h3 id="2-3-使用alter-table-语句在已经存在的表上创建索引"><a href="#2-3-使用alter-table-语句在已经存在的表上创建索引" class="headerlink" title="2.3 使用alter table 语句在已经存在的表上创建索引"></a>2.3 使用alter table 语句在已经存在的表上创建索引</h3><p>在已经存在的表上创建索引，除了可以使用<code>create index</code>语句外，还可以使用<code>alter table</code>语句。使用<code>alter table</code>语句创建索引的语法格式如下所示：</p>
<pre><code>alter table 表名 add [UNIQUE|FULLTEXT|SPATIAL] index
                索引名 （字段名 [(长度)] [ASC|DESC])</code></pre><p>在上述语法中<code>UNIUE、FULLTEXT和SPATIAL</code>都是可选参数，分别用于表示唯一性索引、全文索引和空间索引；add表示像表中添加字段。<br>接下类同样以book表为例，对不同类型的索引进行详解。</p>
<h4 id="2-3-1-创建普通索引"><a href="#2-3-1-创建普通索引" class="headerlink" title="2.3.1 创建普通索引"></a>2.3.1 创建普通索引</h4><p><code>alter table book add index index_id(bookid);</code></p>
<h4 id="2-3-2-创建唯一性索引"><a href="#2-3-2-创建唯一性索引" class="headerlink" title="2.3.2 创建唯一性索引"></a>2.3.2 创建唯一性索引</h4><p><code>alter table book add unique uniqueidx(bookid);</code></p>
<h4 id="2-3-3-创建单列索引"><a href="#2-3-3-创建单列索引" class="headerlink" title="2.3.3 创建单列索引"></a>2.3.3 创建单列索引</h4><p><code>alter table book add index singleidx (comment(50));</code></p>
<h4 id="2-3-4-创建多列索引"><a href="#2-3-4-创建多列索引" class="headerlink" title="2.3.4 创建多列索引"></a>2.3.4 创建多列索引</h4><p><code>alter table book add index multidx(autros(50),info(50));</code></p>
<h4 id="2-3-5-创建全文索引"><a href="#2-3-5-创建全文索引" class="headerlink" title="2.3.5 创建全文索引"></a>2.3.5 创建全文索引</h4><p><code>alter table book add fulltext index fulltextidx(info);</code></p>
<h4 id="2-3-6-创建空间索引"><a href="#2-3-6-创建空间索引" class="headerlink" title="2.3.6 创建空间索引"></a>2.3.6 创建空间索引</h4><p><code>alter table t8 add spatial index spatidx(space);</code></p>
<h2 id="3-删除索引"><a href="#3-删除索引" class="headerlink" title="3.删除索引"></a>3.删除索引</h2><p>由于索引会占用一定的磁盘空间，因此，为了避免影响数据库性能，应该及时删除不在使用的索引。删除索引的方式有两种，具体如下:</p>
<h3 id="3-1使用alter-table删除索引"><a href="#3-1使用alter-table删除索引" class="headerlink" title="3.1使用alter table删除索引"></a>3.1使用alter table删除索引</h3><p>使用<code>alter table``删除索引的基本语法格式如下所示：</code>alter table 表名 drop index 索引名```</p>
<pre><code>alter table book index fulltextidx；</code></pre><h3 id="3-2使用drop-index删除索引"><a href="#3-2使用drop-index删除索引" class="headerlink" title="3.2使用drop index删除索引"></a>3.2使用drop index删除索引</h3><p>使用<code>drop index</code> 删除索引的基本语法格式如下：<br><code>drop index 索引名 on 表名；</code></p>
<pre><code>drop index spatidx on t8;</code></pre>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql表的约束</title>
    <url>/2019/12/18/biao-de-yue-shu/</url>
    <content><![CDATA[<h2 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h2><p>为了防止数据表中插入错误的数据，在mysql中定义了一些维护数据库完整性的规则，即表的约束。<br><img src="http://qiniuyun.dajienihao.cn/image/1218/%E8%A1%A8%E7%9A%84%E7%BA%A6%E6%9D%9F.jpg" alt=""></p>
<h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><h4 id="单字段主键"><a href="#单字段主键" class="headerlink" title="单字段主键"></a>单字段主键</h4><p>单字段主键指的是由一个字段构成的主键，其基本语法格式如下所示:<br><code>字段名 数据类型 primary key；</code></p>
<pre><code> mysql-&gt;create table example(
      -&gt;id int primary key,
      -&gt;name varchar(20),
      -&gt;grade float);</code></pre><h4 id="多字段主键"><a href="#多字段主键" class="headerlink" title="多字段主键"></a>多字段主键</h4><p>多字段主键指的是多个字段组合而成的主键，其基本的语法格式如下所示:<br><code>primary key（字段名1,字段2名,...,字段名n）；</code></p>
<pre><code>     mysql-&gt;create table example1(
         -&gt;stu_id int,
         -&gt;course_id int,
         -&gt;grade float,
         -&gt;primary key(stu_id,course_id));</code></pre><blockquote>
<p>注意：每个数据表中最多只能有一个主键约束，定义为primary key的字段不能有重复值且不能为null值;</p>
</blockquote>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>由于外键约束涉及多表操作，这里就不进行说明了。</p>
<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p>非空约束值得是字段的值不能为null，在MySQL中，非空约束是通过notnull定义的，其基本语法格式如下：<br><code>字段名 数据类型 not null；</code></p>
<pre><code>    mysql-&gt;create table example2(
         -&gt;id int primary key,
         -&gt;name varchar(20) not null,
         -&gt;grade float);</code></pre><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>唯一约束用于保证数据表中字段的唯一性，即表中字段的值不能重复出现。唯一约束是通过    unique定义的，其基本语法的格式如下所示：<br><code>字段名 数据类型 unique；</code></p>
<pre><code>mysql&gt;create table example3(
    -&gt;id int primary key,
    -&gt;stu_id int unique,
    -&gt;name varchar(20)not null);</code></pre><h3 id="自增约束"><a href="#自增约束" class="headerlink" title="自增约束"></a>自增约束</h3><p>在数据表中，若想为表中插入新的记录自动生成唯一的ID,可以使用auto_increment约束来实现。auto_increment约束的字段可以是任何整数类型。默认情况下，该字段的值是从1开始自增的。使用auto_increment设置表字段值自动增加的基本语法格式如下所示：<br><code>字段名 数据类型 auto_increment；</code></p>
<pre><code>    mysql&gt;create table example5(
        -&gt;id int primary key auto_increment,
        -&gt;stu_id int unique,
        -&gt;grade float);</code></pre><h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><p>默认约束用于非数据表中字段指定默认值，即当在表中插入一条新记录是，如果么哦呦给这个字段赋值，那么，数据库系统会自动给这个字段插入默认值。默认值是通过default关键字定义的，其基本的语法格式如下所示：<br><code>字段名 数据类型 default 默认值；</code></p>
<pre><code>    mysql&gt;create table example4(
        -&gt;id int primary key,
        -&gt;stu_id int unique,
        -&gt;grade float default 0);</code></pre>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>表的约束</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据类型详解</title>
    <url>/2019/12/14/mysql-shu-ju-lei-xing-xiang-jie/</url>
    <content><![CDATA[<p>#数据类型<br>使用mysql数据库存储数据时，不同的类型决定了不同mysql不同的存储方式不同。为此mysql数据库提供了多种数据类型，其中包括整数类型、浮点数类型、定点数类型、日期和时间类型和二进制类型。下面将对此进行详解。</p>
<h2 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a>1.整数类型</h2><p>在Mysql数据库中，经常需要存储整数数值。根据数值取值范围的不同，Mysql中的整数类型可分为五种，分别是TINYINT、SMALLINT、MEDIUMINT、INT和BIGINT。<br><img src="http://qiniuyun.dajienihao.cn/image/1211/image.png" alt=""><br>从表中可以看出，不同的整数类型占用的字节数和取值范围都不同。需要注意的是，不同整数类型的取值范围是可以根据字节数算出来的。</p>
<h2 id="2-浮点数类型和定点数类型"><a href="#2-浮点数类型和定点数类型" class="headerlink" title="2.浮点数类型和定点数类型"></a>2.浮点数类型和定点数类型</h2><p>在mysql数据库中小数都是使用浮点数和定点数来表示的。浮点数的类型可以分为单精度浮点数类型（FLOAT）和双精度浮点数类型（DOUBLE）。而定点数类型只有DECMIMAL（M，D）<br><img src="http://qiniuyun.dajienihao.cn/image/1214/%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%92%8C%E5%AE%9A%E7%82%B9%E5%9E%8B.jpg241642558434741.png" alt=""></p>
<p>从表中可以看出DECIMAL类型的取值范围与DOUBLE类型的取值范围相同，需要注意的是DECIMAL的有效取值范围是由M和D决定的。其中，M表示的是数据的长度，D表示小数点后的长度。比如将DECIMAL（6，2）的数据3.14159插入数据库中，现实的结果为3.14。</p>
<h2 id="3-日期与时间类型"><a href="#3-日期与时间类型" class="headerlink" title="3.日期与时间类型"></a>3.日期与时间类型</h2><p>为了方便在数据库中存储时间和日期，mysql提供了表示日期和时间的数据类型。分别是YEAR、DATE、TIME、DATETIME和TIMESTAMP。<br><img src="http://qiniuyun.dajienihao.cn/20191121112931554.jpg" alt=""><br>从表中可以看出每种日期和时间类型的取值范围都是不同的。需要注意的是如果插入的数值不合法，系统会自动将对应的零值插入数据库中。</p>
<h2 id="4-字符串和二进制类型"><a href="#4-字符串和二进制类型" class="headerlink" title="4.字符串和二进制类型"></a>4.字符串和二进制类型</h2><p>为了存储字符串、图片和声音等数据，mysql提供了字符串类型和二进制类型。<br><img src="http://qiniuyun.dajienihao.cn/image/1214/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9E%8B.jpg" alt=""><br>表中列举的字符串和二进制类型，不同的数据类型具有不同的特点。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库及表的基本操作</title>
    <url>/2019/12/11/mysql-shu-ju-ku-ji-biao-de-ji-ben-cao-zuo/</url>
    <content><![CDATA[<h2 id="mysql简单操作"><a href="#mysql简单操作" class="headerlink" title="mysql简单操作"></a>mysql简单操作</h2><h3 id="mysql服务的启动与暂停"><a href="#mysql服务的启动与暂停" class="headerlink" title="mysql服务的启动与暂停"></a>mysql服务的启动与暂停</h3><pre><code>net start mysql
net stop mysql</code></pre><h3 id="mysql登录"><a href="#mysql登录" class="headerlink" title="mysql登录"></a>mysql登录</h3><pre><code>-u用户名 -p密码</code></pre><h3 id="创建和查看数据库"><a href="#创建和查看数据库" class="headerlink" title="创建和查看数据库"></a>创建和查看数据库</h3><pre><code>create database 数据库名称
show crate database 数据库名称</code></pre><h3 id="修改数据库编码"><a href="#修改数据库编码" class="headerlink" title="修改数据库编码"></a>修改数据库编码</h3><pre><code>alter database 数据库名称 default character set 编码方式 collate 编码方式_bin</code></pre><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre><code>drop database 数据库名称</code></pre><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code>create table 表名（
字段1，数据类型[完整性约束条件]
字段2，数据类型[完整性约束条件]
.......
）</code></pre><h3 id="查看库中表"><a href="#查看库中表" class="headerlink" title="查看库中表"></a>查看库中表</h3><pre><code>show tables</code></pre><h3 id="查看数据表"><a href="#查看数据表" class="headerlink" title="查看数据表"></a>查看数据表</h3><pre><code>1.show create table 表名（后加\G可以使结果整齐美观）
2.desc 表名</code></pre><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><pre><code>alter table 表名 rename [to] 新表名</code></pre><h3 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h3><pre><code>alter table 表名 change 旧字段名 新字段名 数据类型</code></pre><h3 id="修改字段的数据类型"><a href="#修改字段的数据类型" class="headerlink" title="修改字段的数据类型"></a>修改字段的数据类型</h3><pre><code>alter table 表名 modify 字段名 数据类型</code></pre><h3 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h3><pre><code>alter table 表名 add 新字段名 数据类型[约束条件][first|after 已存在字段名]</code></pre><h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><pre><code>alter table 表名 drop 字段名</code></pre><h3 id="修改字段的排列位置"><a href="#修改字段的排列位置" class="headerlink" title="修改字段的排列位置"></a>修改字段的排列位置</h3><pre><code>alter table 表名 modify 字段名1 数据类型 first|after 字段名2</code></pre><h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><pre><code>drop table 表名   </code></pre>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC设计模式</title>
    <url>/2019/12/08/mvc-she-ji-mo-shi/</url>
    <content><![CDATA[<h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><p><strong>MVC</strong>全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<ul>
<li><p>Model（模型） 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</p>
</li>
<li><p>View（视图） - 视图代表模型包含的数据的可视化。</p>
</li>
<li><p>Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</p>
</li>
</ul>
<p><img src="http://qiniuyun.dajienihao.cn/image/1208/mvc%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h2 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h2><p>毕竟没有什么设计模式是完美的，优点和缺点总是各有千秋。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="1-低耦合"><a href="#1-低耦合" class="headerlink" title="1.低耦合"></a>1.低耦合</h4><p>通过将视图层和业务层分离，允许更改视图层代码而不必重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变，只需要改动MVC的模型层（及控制器）即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。</p>
<p>模型层是自包含的，并且与控制器和视图层相分离，所以很容易改变应用程序的数据层和业务规则。如果想把数据库从 MySQL 移植到 Oracle，或者改变基于 RDBMS 的数据源到 LDAP，只需改变模型层即可。一旦正确的实现了模型层，不管数据来自数据库或是 LDAP服务器，视图层都将会正确的显示它们。由于运用 MVC 的应用程序的三个部件是相互独立，改变其中一个部件并不会影响其它两个，所以依据这种设计思想能构造出良好的松耦合的构件。</p>
<h4 id="2-重用性高"><a href="#2-重用性高" class="headerlink" title="2.重用性高"></a>2.重用性高</h4><p>随着技术的不断进步，当前需要使用越来越多的方式来访问应用程序了。MVC模式允许使用各种不同样式的视图来访问同一个服务端的代码，这得益于多个视图（如WEB（HTTP）浏览器或者无线浏览器（WAP））能共享一个模型。</p>
<p>比如，用户可以通过电脑或通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式（流程）是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面（视图）使用。例如，很多数据可能用 HTML 来表示，但是也有可能用 WAP 来表示，而这些表示的变化所需要的是仅仅是改变视图层的实现方式，而控制层和模型层无需做任何改变。</p>
<p>由于已经将数据和业务规则从表示层分开，所以可以最大化的进行代码重用了。另外，模型层也有状态管理和数据持久性处理的功能，所以，基于会话的购物车和电子商务过程，也能被Flash网站或者无线联网的应用程序所重用。</p>
<h4 id="3-生命周期成本低"><a href="#3-生命周期成本低" class="headerlink" title="3.生命周期成本低"></a>3.生命周期成本低</h4><p>MVC模式使开发和维护用户接口的技术含量降低。</p>
<h4 id="4-部署快"><a href="#4-部署快" class="headerlink" title="4.部署快"></a>4.部署快</h4><p>使用MVC模式进行软件开发，使得软件开发时间得到相当大的缩减，它使后台程序员集中精力于业务逻辑，界面程序员集中精力于表现形式上。</p>
<h4 id="5-可维护性高"><a href="#5-可维护性高" class="headerlink" title="5.可维护性高"></a>5.可维护性高</h4><p>分离视图层和业务逻辑层使得WEB应用更易于维护和修改。</p>
<h4 id="6-有利软件工程化管理"><a href="#6-有利软件工程化管理" class="headerlink" title="6.有利软件工程化管理"></a>6.有利软件工程化管理</h4><p>由于不同的组件（层）各司其职，每一层不同的应用会具有某些相同的特征，这样就有利于通过工程化、工具化的方式管理程序代码。控制器同时还提供了一个好处，就是可以使用控制器来联接不同的模型和视图，来实现用户的需求，这样控制器可以为构造应用程序提供强有力的手段。给定一些可重用的模型和视图，控制器可以根据用户的需求选择模型进行处理，然后选择视图将处理结果显示给用户。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="1-没有明确的定义"><a href="#1-没有明确的定义" class="headerlink" title="1.没有明确的定义"></a>1.没有明确的定义</h4><p>完全理解MVC模式并不是很容易。使用MVC模式需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考软件的架构。同时由于模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难。每个构件在使用之前都需要经过彻底的测试。</p>
<h4 id="2-不适合小、中型应用程序"><a href="#2-不适合小、中型应用程序" class="headerlink" title="2.不适合小、中型应用程序"></a>2.不适合小、中型应用程序</h4><p>花费大量时间将MVC模式应用到规模并不是很大的应用程序通常会得不偿失。</p>
<h4 id="3-增加系统结构和实现的复杂性"><a href="#3-增加系统结构和实现的复杂性" class="headerlink" title="3.增加系统结构和实现的复杂性"></a>3.增加系统结构和实现的复杂性</h4><p>对于简单的界面来说，非要严格遵循MVC模式，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</p>
<p>####4.视图对模型数据的低效率访问 ####<br>依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</p>
]]></content>
      <categories>
        <category>MVC</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse导入普通javaweb项目报错问题</title>
    <url>/2019/11/23/eclipse-dao-ru-pu-tong-javaweb-xiang-mu-bao-cuo-wen-ti/</url>
    <content><![CDATA[<h2 id="Eclipse导入javaweb项目代码报错解决方案"><a href="#Eclipse导入javaweb项目代码报错解决方案" class="headerlink" title="Eclipse导入javaweb项目代码报错解决方案"></a>Eclipse导入javaweb项目代码报错解决方案</h2><p>相信大家在前期学习javaweb的时候导入项目都会碰到一个问题，那就是导入Javaweb项目时代码没有报错但项目图标就是有红叉。</p>
<p>以下是我导入项目发生的错误，我带大家看一下<br><img src="http://qiniuyun.dajienihao.cn/1122%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99.png" alt=""><br>导入项目时会出现这样的错误，jsp页面全部报错！下面我把我如何解决的方法告诉大家：</p>
<h3 id="1-首先，点开你导入项目的项目名，右键选择Build-Path-gt-Configure-Build-Path"><a href="#1-首先，点开你导入项目的项目名，右键选择Build-Path-gt-Configure-Build-Path" class="headerlink" title="1.首先，点开你导入项目的项目名，右键选择Build Path--------&gt;Configure Build Path"></a><strong>1.首先，点开你导入项目的项目名，右键选择<code>Build Path--------&gt;Configure Build Path</code></strong></h3><p><img src="http://qiniuyun.dajienihao.cn/1122lib.png" alt=""></p>
<h4 id="1-选中有红叉的jre点击remove"><a href="#1-选中有红叉的jre点击remove" class="headerlink" title="1.选中有红叉的jre点击remove"></a>1.选中有红叉的jre点击remove</h4><h4 id="2-然后点击Add-Library"><a href="#2-然后点击Add-Library" class="headerlink" title="2.然后点击Add Library"></a>2.然后点击Add Library</h4><h4 id="3-选择JRE-System-Library-点击next"><a href="#3-选择JRE-System-Library-点击next" class="headerlink" title="3.选择JRE System Library 点击next"></a>3.选择JRE System Library 点击next</h4><p><img src="http://qiniuyun.dajienihao.cn/1122addlib.png" alt=""></p>
<h4 id="4-点击Installed选择你的你本机的jre在点击Apply即可"><a href="#4-点击Installed选择你的你本机的jre在点击Apply即可" class="headerlink" title="4.点击Installed选择你的你本机的jre在点击Apply即可"></a>4.点击Installed选择你的你本机的jre在点击Apply即可</h4><p><img src="http://qiniuyun.dajienihao.cn/addjre.png" alt=""></p>
<h3 id="2-在再左边找到Project-Facets"><a href="#2-在再左边找到Project-Facets" class="headerlink" title="2.在再左边找到Project Facets"></a><strong>2.在再左边找到Project Facets</strong></h3><h4 id="1-点击java栏右边下拉框-选择你的版本（我这里是1-8版本所以我选择1-8版本）"><a href="#1-点击java栏右边下拉框-选择你的版本（我这里是1-8版本所以我选择1-8版本）" class="headerlink" title="1.点击java栏右边下拉框 选择你的版本（我这里是1.8版本所以我选择1.8版本）"></a>1.点击java栏右边下拉框 选择你的版本（我这里是1.8版本所以我选择1.8版本）</h4><p><img src="http://qiniuyun.dajienihao.cn/add1.8.png" alt=""></p>
<h4 id="2-再点击Run-Times选择你的Tomcat版本-如果没有的的话new一个然后Apply就发现-报错已经全部消失了"><a href="#2-再点击Run-Times选择你的Tomcat版本-如果没有的的话new一个然后Apply就发现-报错已经全部消失了" class="headerlink" title="2.再点击Run Times选择你的Tomcat版本 如果没有的的话new一个然后Apply就发现 报错已经全部消失了"></a>2.再点击Run Times选择你的Tomcat版本 如果没有的的话new一个然后Apply就发现 报错已经全部消失了</h4><p><img src="http://qiniuyun.dajienihao.cn/finsh.png" alt=""></p>
<h3 id="3-到这里就已经成功了嗷，如果还有问题的话可以私聊我"><a href="#3-到这里就已经成功了嗷，如果还有问题的话可以私聊我" class="headerlink" title="3.到这里就已经成功了嗷，如果还有问题的话可以私聊我"></a>3.到这里就已经成功了嗷，如果还有问题的话可以私聊我</h3>]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>后端</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射基础</title>
    <url>/2019/10/31/java-ji-chu-fan-she/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Java反射(<code>Reflection</code>)机制就是在运行状态中，对于任意一个类，都能够知道这个类的属性和方法。对于任意一个对象能够调用它的任意一个属性和方法。这种动态获取的信息和动态调用对象的方法的功能称为Java语言的反射机制。Java程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p>反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。反射机制就是通过<code>java.lang.Class</code>类来实现的，在<code>Java</code>中，<code>Object</code>类是所有类的根类，而<code>Class</code>类就是描述Java类的类。</p>
<blockquote>
<p>注：因为<code>Class</code>类也是类，所以<code>Object</code>也包括<code>Class</code>类。</p>
</blockquote>
<h3 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2. 主要功能"></a>2. 主要功能</h3><p>Java反射框架主要提供以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用<code>private</code>方法）；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>修改构造函数、方法、属性的可见性。</li>
</ul>
<h3 id="3-主要用途"><a href="#3-主要用途" class="headerlink" title="3. 主要用途"></a>3. 主要用途</h3><p><strong>反射最重要的用途就是开发各种通用框架</strong>。很多框架（比如<code>Spring</code>）都是配置化的（比如通过XML文件配置<code>JavaBean</code>,<code>Action</code>之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。</p>
<h2 id="二、反射的作用"><a href="#二、反射的作用" class="headerlink" title="二、反射的作用"></a>二、反射的作用</h2><h3 id="1-获取class对象"><a href="#1-获取class对象" class="headerlink" title="1. 获取class对象"></a>1. 获取class对象</h3><p>反射的各种功能都需要通过<code>Class</code>对象来实现，因此，需要知道如何获取<code>Class</code>对象，主要有以下几种方式。</p>
<h4 id="使用-Class-forName-的静态方法"><a href="#使用-Class-forName-的静态方法" class="headerlink" title="使用 Class.forName() 的静态方法"></a>使用 Class.forName() 的静态方法</h4><p><code>Class.forName(String className)</code>方法可以通过类或接口的名称（一个字符串或完全限定名）来获取对应的<code>Class</code>对象。</p>
<pre class=" language-java"><code class="language-java">    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.blinkfox.Zealot"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="直接获取某个类的class-最安全-性能最好"><a href="#直接获取某个类的class-最安全-性能最好" class="headerlink" title="直接获取某个类的class(最安全/性能最好)"></a>直接获取某个类的class(最安全/性能最好)</h4><pre class=" language-java"><code class="language-java">    Class<span class="token operator">&lt;</span>String<span class="token operator">></span> cls <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span></code></pre>
<h4 id="调用某个对象的-getClass-方法"><a href="#调用某个对象的-getClass-方法" class="headerlink" title="调用某个对象的 getClass() 方法"></a>调用某个对象的 getClass() 方法</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="2-判断是否为某个类的实例"><a href="#2-判断是否为某个类的实例" class="headerlink" title="2. 判断是否为某个类的实例"></a>2. 判断是否为某个类的实例</h3><p>一般地，我们用<code>instanceo</code>f关键字来判断是否为某个类的实例。同时我们也可以借助反射中<code>Class</code>对象的<code>isInstance()</code>方法来判断是否为某个类的实例，它是一个<code>Native</code>方法：</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="3-创建实例"><a href="#3-创建实例" class="headerlink" title="3. 创建实例"></a>3. 创建实例</h3><p>通过反射来生成对象主要有两种方式。</p>
<h4 id="使用Class对象的newInstance-方法"><a href="#使用Class对象的newInstance-方法" class="headerlink" title="使用Class对象的newInstance()方法"></a>使用Class对象的newInstance()方法</h4><pre class=" language-java"><code class="language-java">    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    Object str <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance-方法"><a href="#通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance-方法" class="headerlink" title="通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法"></a>通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法</h4><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 获取String所对应的Class对象</span>
    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 获取String类带一个String参数的构造器</span>
    Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 根据构造器创建实例</span>
    Object obj <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"23333"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>注：这种方法可以用指定的构造器构造类的实例。</p>
</blockquote>
<h3 id="4-获取方法"><a href="#4-获取方法" class="headerlink" title="4. 获取方法"></a>4. 获取方法</h3><p>获取某个<code>Class</code>对象的方法集合，主要有以下几个方法：</p>
<ul>
<li><code>getDeclaredMethods</code>()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</li>
</ul>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException</code></pre>
<ul>
<li><code>getMethods</code>()方法返回某个类的所有公用（<code>public</code>）方法，包括其继承类的公用方法。</li>
</ul>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException
</code></pre>
<ul>
<li><code>getMethod</code>()方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应<code>Class</code>的对象。</li>
</ul>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Method <span class="token function">getMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span></code></pre>
<p>代码示例：</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span>
    <span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>
    InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>
    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> MethodClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    Object object <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Method<span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Method<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredMethods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//获取MethodClass类的add方法</span>
    Method method <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//getMethods()方法获取的所有方法</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getMethods获取的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//getDeclaredMethods()方法获取的所有方法</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getDeclaredMethods获取的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span> declaredMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">MethodClass</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fuck <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">}</span></code></pre>
<blockquote>
<p>注：通过<code>getMethods()</code>获取的方法可以获取到父类的方法,比如<code>java.lang.Object</code>下定义的各个方法。</p>
</blockquote>
<h3 id="5-获取构造方法"><a href="#5-获取构造方法" class="headerlink" title="5. 获取构造方法"></a>5. 获取构造方法</h3><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过<code>Class</code>类的<code>getConstructor</code>方法得到<code>Constructor</code>类的一个实例，而<code>Constructor</code>类有一个<code>newInstance</code>方法可以创建一个对象实例:</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> T <span class="token function">newInstance</span><span class="token punctuation">(</span>Object <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initargs<span class="token punctuation">)</span></code></pre>
<h3 id="6-获取类的成员变量信息"><a href="#6-获取类的成员变量信息" class="headerlink" title="6. 获取类的成员变量信息"></a>6. 获取类的成员变量信息</h3><p>获取的方法同<code>Method</code>相似，主要是这几个方法，在此不再赘述：</p>
<ul>
<li><code>Field getField(String name)</code>: 访问公有的成员变量。</li>
</ul>
<ul>
<li><code>Field[] getDeclaredFields()</code>：所有已声明的成员变量。但不能得到其父类的成员变量。</li>
</ul>
<ul>
<li><p><code>Field[] getFields()</code>和<code>Field[] getDeclaredFields()</code>用法同上。</p>
<h3 id="7-调用方法"><a href="#7-调用方法" class="headerlink" title="7. 调用方法"></a>7. 调用方法</h3><p>当我们从类中获取了一个方法后，我们就可以用<code>invoke()</code>方法来调用这个方法。<code>invoke</code>方法的原型为:</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span>
   InvocationTargetException</code></pre>
<p>代码示例：</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>
  InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>
  Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> klass <span class="token operator">=</span> MethodClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//创建 MethodClass 的实例</span>
  Object obj <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//获取 MethodClass 类的add方法</span>
  Method method <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//调用 method 对应的方法 => add(1,4)</span>
  Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">class</span> <span class="token class-name">MethodClass</span> <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fuck <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token punctuation">}</span></code></pre>
<h3 id="8-利用反射创建数组"><a href="#8-利用反射创建数组" class="headerlink" title="8. 利用反射创建数组"></a>8. 利用反射创建数组</h3><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个<code>Object Reference</code>。下面我们看一看利用反射创建数组的例子：</p>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 使用`java.lang.reflect.Array`反射创建长度为25的字符串数组.</span>
  Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Object array <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 往数组里添加内容</span>
  Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Go"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Scala"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"Clojure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 获取某一项的内容</span>
  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
<h2 id="三、使用反射获取信息"><a href="#三、使用反射获取信息" class="headerlink" title="三、使用反射获取信息"></a>三、使用反射获取信息</h2><p><code>Class</code>类提供了大量的实例方法来获取该<code>Class</code>对象所对应的详细信息，<code>Class</code>类大致包含如下方法，其中每个方法都包含多个重载版本，因此我们只是做简单的介绍，详细请参考JDK文档。</p>
</li>
</ul>
<h3 id="1-获取类内信息"><a href="#1-获取类内信息" class="headerlink" title="1. 获取类内信息"></a>1. 获取类内信息</h3><ul>
<li>构造器: <code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></li>
<li>包含的方法: <code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></li>
<li>包含的属性: <code>Field getField(String name)</code></li>
<li>内部类: <code>Class&lt;?&gt;[] getDeclaredClasses()</code></li>
<li>外部类: <code>Class&lt;?&gt; getDeclaringClass()</code></li>
<li>所实现的接口: <code>Class&lt;?&gt;[] getInterfaces()</code></li>
<li>修饰符: <code>int getModifiers()</code></li>
<li>所在包: <code>Package getPackage()</code></li>
<li>类名: <code>String getName()</code></li>
<li>简称: <code>String getSimpleName()</code></li>
</ul>
<h3 id="2-判断类本身信息的方法"><a href="#2-判断类本身信息的方法" class="headerlink" title="2. 判断类本身信息的方法"></a>2. 判断类本身信息的方法</h3><ul>
<li>是否注解类型: <code>boolean isAnnotation()</code></li>
<li>是否使用了该<code>Annotation</code>修饰: <code>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></li>
<li>是否匿名类: <code>boolean isAnonymousClass()</code></li>
<li>是否数组: <code>boolean isArray()</code></li>
<li>是否枚举: <code>boolean isEnum()</code></li>
<li>是否原始类型: <code>boolean isPrimitive()</code></li>
<li>是否接口: <code>boolean isInterface()</code></li>
<li>obj是否是该Class的实例: <code>boolean isInstance(Object obj)</code></li>
</ul>
<h3 id="3-使用反射获取泛型信息"><a href="#3-使用反射获取泛型信息" class="headerlink" title="3. 使用反射获取泛型信息"></a>3. 使用反射获取泛型信息</h3><p>为了通过反射操作泛型以迎合实际开发的需要, <code>Java</code>新增了<code>java.lang.reflect.ParameterizedType、java.lang.reflect.GenericArrayType、java.lang.reflect.TypeVariable、java.lang.reflect.WildcardType</code>几种类型来代表不能归一到<code>Class</code>类型但是又和原始类型同样重要的类型。</p>
<p>-<code>ParameterizedType</code>: 一种参数化类型, 比如<code>Collection</code></p>
<ul>
<li><code>GenericArrayType</code>: 一种元素类型是参数化类型或者类型变量的数组类型</li>
<li><code>TypeVariable</code>: 各种类型变量的公共接口</li>
<li><code>WildcardType</code>: 一种通配符类型表达式, 如<code>?、? extends Number、? super Integer</code></li>
</ul>
<p>代码示例：</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> objectMap<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> User<span class="token operator">></span> map<span class="token punctuation">,</span> String string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>User<span class="token punctuation">,</span> Bean<span class="token operator">></span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 测试属性类型
     *
     * @throws NoSuchFieldException
     */</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFieldType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException <span class="token punctuation">{</span>
    Field field <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"objectMap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Type gType <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getGenericType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 打印type与generic type的区别</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>gType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ParameterizedType pType <span class="token operator">=</span> <span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> gType<span class="token punctuation">;</span>
    Type<span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> pType<span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> types<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 测试参数类型
     *
     * @throws NoSuchMethodException
     */</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testParamType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>
    Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Type<span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> parameterTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"type -> "</span> <span class="token operator">+</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 测试返回值类型
     *
     * @throws NoSuchMethodException
     */</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>
    Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Type returnType <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"return type -> "</span> <span class="token operator">+</span> returnType<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>returnType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> returnType<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
]]></content>
      <categories>
        <category>反射</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
</search>
